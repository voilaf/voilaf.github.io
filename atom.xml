<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://voilaf.github.io</id>
    <title>voilaf</title>
    <updated>2022-03-23T13:50:56.133Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://voilaf.github.io"/>
    <link rel="self" href="https://voilaf.github.io/atom.xml"/>
    <subtitle>hhh</subtitle>
    <logo>https://voilaf.github.io/images/avatar.png</logo>
    <icon>https://voilaf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, voilaf</rights>
    <entry>
        <title type="html"><![CDATA[PropertySource如何维护配置信息]]></title>
        <id>https://voilaf.github.io/post/propertysource-ru-he-wei-hu-pei-zhi-xin-xi/</id>
        <link href="https://voilaf.github.io/post/propertysource-ru-he-wei-hu-pei-zhi-xin-xi/">
        </link>
        <updated>2022-03-21T14:24:19.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%9B%AE%E7%9A%84">目的</a></li>
<li><a href="#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">过程分析</a>
<ul>
<li><a href="#%E5%85%B3%E9%94%AE-class-%E5%92%8C-interface">关键 class 和  interface</a>
<ul>
<li><a href="#propertysource">PropertySource</a></li>
<li><a href="#abstractenvironment%E5%AF%B9%E5%BA%94%E5%B1%9E%E6%80%A7">AbstractEnvironment对应属性</a></li>
<li><a href="#configurationpropertysourcespropertysource">ConfigurationPropertySourcesPropertySource</a></li>
</ul>
</li>
<li><a href="#%E6%80%8E%E4%B9%88%E5%8F%96">怎么取</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E5%AD%98">怎么存</a></li>
</ul>
</li>
<li><a href="#faq">FAQ</a>
<ul>
<li><a href="#springboot%E4%B8%ADvalue%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E7%9A%84%E5%80%BC%E4%BB%8E%E4%BD%95%E6%9D%A5">Springboot中Value注解注入的值从何来</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99">读取配置优先级规则</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81propertysource%E7%B1%BB">常见PropertySource类</a></li>
<li><a href="#addfirst%E5%92%8Caddlast%E7%9A%84%E5%8C%BA%E5%88%AB">addFirst和addLast的区别</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="目的">目的</h1>
<p>springboot中配置信息如何通过PropertySource、MutablePropertySources、ConfigurationPropertySourcesPropertySource等相关类进行维护</p>
<h1 id="版本">版本</h1>
<p>spring-boot-version: 2.3.2.RELEASE</p>
<h1 id="过程分析">过程分析</h1>
<h2 id="关键-class-和-interface">关键 class 和  interface</h2>
<h3 id="propertysource">PropertySource</h3>
<pre><code>public abstract class PropertySource&lt;T&gt; {
    protected final String name;
	protected final T source;
}
</code></pre>
<blockquote>
<p>Abstract base class representing a source of name/value property pairs. The underlying source object may be of any type T that encapsulates properties. Examples include java.util.Properties objects, java.util.Map objects, ServletContext and ServletConfig objects (for access to init parameters).</p>
</blockquote>
<p>在Spring中以PropertySource作为一个单元，存储一个配置集。比如环境变量是一个PropertySource，命令行参数是一个PropertySource，application.properties是一个PropertySource等等<br>
<code>name</code>指代配置集的名词，source以泛型实现类型存储任意类型的真实配置信息（如Map）</p>
<h3 id="abstractenvironment对应属性">AbstractEnvironment对应属性</h3>
<pre><code>public abstract class AbstractEnvironment implements ConfigurableEnvironment {
    private final MutablePropertySources propertySources = new MutablePropertySources();

	private final ConfigurablePropertyResolver propertyResolver =
			new PropertySourcesPropertyResolver(this.propertySources);
}
</code></pre>
<p>Spring项目启动一定会创建一个Environment，即使依赖包不一样，StandardEnvironment、StandardServletEnvironment、StandardReactiveWebEnvironment，但都继承自AbstractEnvironment，AbstractEnvironment内包含<code>propertySources</code>和<code>propertyResolver</code>属性，这就是配置信息存储和解析的地方</p>
<pre><code>public class MutablePropertySources implements PropertySources {
    private final List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = new CopyOnWriteArrayList&lt;&gt;();
}
</code></pre>
<blockquote>
<p>The default implementation of the PropertySources interface. Allows manipulation of contained property sources and provides a constructor for copying an existing PropertySources instance.<br>
Where precedence is mentioned in methods such as addFirst and addLast, this is with regard to the order in which property sources will be searched when resolving a given property with a PropertyResolver.</p>
</blockquote>
<pre><code>public class PropertySourcesPropertyResolver extends AbstractPropertyResolver {
	private final PropertySources propertySources;
}
</code></pre>
<blockquote>
<p>PropertyResolver implementation that resolves property values against an underlying set of PropertySources.</p>
</blockquote>
<p>结合以上两个类和各自的属性一起看，MutablePropertySources的<code>propertySourceList</code>存储多个PropertySource，即所有的配置集合。而PropertySourcesPropertyResolver持有MutablePropertySources变量的引用，也就间接持有了所有配置集的引用。</p>
<p>观察PropertySourcesPropertyResolver内部的方法，会发现真实获取配置信息的位置就在此处，同样的，在使用中，我们常通过<code>${config_name:default_value}</code>占位符来获取真正的数据，PropertySourcesPropertyResolver除了遍历PropertySources外，第二个作用就是解析变量替换占位符</p>
<h3 id="configurationpropertysourcespropertysource">ConfigurationPropertySourcesPropertySource</h3>
<pre><code>class ConfigurationPropertySourcesPropertySource extends PropertySource&lt;Iterable&lt;ConfigurationPropertySource&gt;&gt;
		implements OriginLookup&lt;String&gt; {}
</code></pre>
<blockquote>
<p>PropertySource that exposes ConfigurationPropertySource instances so that they can be used with a PropertyResolver or added to the Environment.</p>
</blockquote>
<p><code>name</code>: configurationProperties<br>
<code>source</code>: class SpringConfigurationPropertySources</p>
<p>source内存储了其他所有的PropertySource，当前PropertySource优先级最高，调用getProperty方法获取属性值时，会循环SpringConfigurationPropertySources内的每一个PropertySource封装ConfigurationPropertySource</p>
<p>至于为什么做还不太明白，另外Springboot的Binder相关操作是基于ConfigurationPropertySource的，也许是为了逻辑的共用？</p>
<h2 id="怎么取">怎么取</h2>
<pre><code>(ConfigurableEnvironment) applicationContext.getEnvironment().getProperty(&quot;xxx.xxx&quot;);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1648040578352.png" alt="" loading="lazy"></figure>
<h2 id="怎么存">怎么存</h2>
<pre><code>ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();

String myPropertySourceName = &quot;myPropertySource&quot;;
Map&lt;String, Object&gt; myPropertySourceMap = new HashMap&lt;&gt;();
myPropertySourceMap.put(&quot;my.username&quot;, &quot;test&quot;);
MapPropertySource mapPropertySource = new MapPropertySource(myPropertySourceName, myPropertySourceMap);

environment.getPropertySources().addFirst(mapPropertySource);

System.out.println(environment.getProperty(&quot;my.username&quot;));

// 输出：test
</code></pre>
<ol>
<li>创新自定义的MapPropertySource，需指定PropertySource的名称和source对应的Map</li>
<li>添加到Environment内的PropertySources内，addFirst、addLast等等方法都可以使用，区分优先级</li>
</ol>
<h1 id="faq">FAQ</h1>
<h2 id="springboot中value注解注入的值从何来">Springboot中Value注解注入的值从何来</h2>
<p>使用Value注解的Bean实例化过程中，会调用<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>方法完成Value和Autowired注解属性变量的注入</p>
<pre><code>@Override
public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
    // 查找当前Bean内Value和Autowired注解信息
    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
    ......
        // 根据注解信息，解析对应值，通过反射注入到Bean内
        metadata.inject(bean, beanName, pvs);
    .......
}
</code></pre>
<h2 id="读取配置优先级规则">读取配置优先级规则</h2>
<p>根据ProperSources实现类MutablePropertySources的<code>propertySourceList</code>列表中的元素位置，配置集的优先级越高，对应在列表中的下标越小</p>
<h2 id="常见propertysource类">常见PropertySource类</h2>
<table>
<thead>
<tr>
<th>PropertySource类名</th>
<th>name</th>
<th>source</th>
<th>添加位置</th>
<th>说明</th>
<th>优先级（1最大，2次之，类比）</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigurationPropertySourcesPropertySource</td>
<td>configurationProperties</td>
<td>SpringConfigurationPropertySources</td>
<td>org.springframework.boot.context.properties.source.ConfigurationPropertySources#attach</td>
<td>内部存储其他的PropertySource</td>
<td>1</td>
</tr>
<tr>
<td>StubPropertySource</td>
<td>servletConfigInitParams</td>
<td>Object</td>
<td>org.springframework.web.context.support.StandardServletEnvironment#customizePropertySources</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>StubPropertySource</td>
<td>servletContextInitParams</td>
<td>Object</td>
<td>org.springframework.web.context.support.StandardServletEnvironment#customizePropertySources</td>
<td></td>
<td>3</td>
</tr>
<tr>
<td>PropertiesPropertySource</td>
<td>systemProperties</td>
<td>Properties</td>
<td>org.springframework.core.env.StandardEnvironment#customizePropertySources</td>
<td>系统配置</td>
<td>4</td>
</tr>
<tr>
<td>OriginAwareSystemEnvironmentPropertySource</td>
<td>systemEnvironment</td>
<td>Map&lt;String, Object&gt;</td>
<td>org.springframework.core.env.StandardEnvironment#customizePropertySources</td>
<td>系统变量</td>
<td>5</td>
</tr>
<tr>
<td>RandomValuePropertySource</td>
<td>random</td>
<td>Random</td>
<td></td>
<td>随机数获取</td>
<td>6</td>
</tr>
<tr>
<td>OriginTrackedMapPropertySource</td>
<td>applicationConfig: [classpath:/application.properties]</td>
<td>Map&lt;String, Object&gt;</td>
<td>org.springframework.boot.context.config.ConfigFileApplicationListener#postProcessEnvironment</td>
<td>application.properties</td>
<td>7</td>
</tr>
</tbody>
</table>
<h2 id="addfirst和addlast的区别">addFirst和addLast的区别</h2>
<pre><code>// Add the given property source object with highest precedence
public void addFirst(PropertySource&lt;?&gt; propertySource) {
    synchronized (this.propertySourceList) {
        removeIfPresent(propertySource);
        this.propertySourceList.add(0, propertySource);
    }
}

// Add the given property source object with lowest precedence.
public void addLast(PropertySource&lt;?&gt; propertySource) {
    synchronized (this.propertySourceList) {
        removeIfPresent(propertySource);
        this.propertySourceList.add(propertySource);
    }
}
</code></pre>
<p>添加到propertySourceList列表的下标不同，一前一后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nacos-config-1.4.x长轮询]]></title>
        <id>https://voilaf.github.io/post/nacos-config-14x-chang-lun-xun/</id>
        <link href="https://voilaf.github.io/post/nacos-config-14x-chang-lun-xun/">
        </link>
        <updated>2022-03-17T13:12:35.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%9B%AE%E7%9A%84">目的</a></li>
<li><a href="#client%E6%B5%81%E7%A8%8B">client流程</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5">客户端接入</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%B1%BB">关键类</a>
<ul>
<li><a href="#nacosconfigservice">NacosConfigService</a></li>
<li><a href="#clientworker">ClientWorker</a></li>
<li><a href="#httpagent">HttpAgent</a></li>
<li><a href="#cachedata">CacheData</a></li>
<li><a href="#listener">Listener</a></li>
</ul>
</li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%95%BF%E8%BD%AE%E8%AF%A2">客户端长轮询</a></li>
</ul>
</li>
<li><a href="#server%E6%B5%81%E7%A8%8B">server流程</a>
<ul>
<li><a href="#%E5%88%A4%E6%96%AD%E9%85%8D%E7%BD%AE%E9%9B%86%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0">判断配置集是否更新</a></li>
</ul>
</li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0">两种接入方式的自动刷新</a>
<ul>
<li><a href="#nacos-config-spring-boot-starter">nacos-config-spring-boot-starter</a>
<ul>
<li><a href="#nacosvalue%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%88%9D%E6%AC%A1%E6%B3%A8%E5%85%A5">NacosValue注解如何完成初次注入</a></li>
<li><a href="#%E6%89%93%E5%BC%80autorreshed%E9%80%89%E9%A1%B9%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0">打开autoRreshed选项如何完成实时动态刷新</a></li>
</ul>
</li>
<li><a href="#spring-cloud-starter-alibaba-nacos-config">spring-cloud-starter-alibaba-nacos-config</a>
<ul>
<li><a href="#value%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%88%9D%E6%AC%A1%E6%B3%A8%E5%85%A5">Value注解如何完成初次注入</a></li>
<li><a href="#refreshscope%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0">RefreshScope如何完成实时动态刷新</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%BB%8F%E6%84%8F%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98">一个不经意可能会发生的问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>及格的代码能跑通逻辑，良好的代码有层次化的设计，优秀的代码有令人惊叹且愉悦的注释说明</p>
</blockquote>
<h1 id="目的">目的</h1>
<p>nacos1.4版本单机模式的config模块长轮询的过程</p>
<h1 id="client流程">client流程</h1>
<p>有三种接入方式，分别为nacos-config-spring-boot-starter、spring-cloud-starter-alibaba-nacos-config、nacos-client。前两种是nacos-client的封装，根据身边使用情况来看，第二种方式用的更多，当前仅分析nacos-client的实现</p>
<h2 id="客户端接入">客户端接入</h2>
<p>pom依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
    &lt;version&gt;1.4.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>测试代码</p>
<pre><code>public static void main(String[] args) throws Exception {
    ConfigService configService = NacosFactory.createConfigService(&quot;127.0.0.1:8848&quot;);
    String configInfo = configService.getConfigAndSignListener(&quot;demo-data-id&quot;, &quot;DEFAULT_GROUP&quot;, 5000, new Listener() {
        @Override
        public Executor getExecutor() {
            return null;
        }

        @Override
        public void receiveConfigInfo(String configInfo) {
            System.out.println(&quot;receive configInfo: =&gt; &quot; + configInfo);
        }
    });
    System.out.println(&quot;init configInfo: =&gt; &quot; + configInfo);
    for (int i=0; i&lt;1; i++) {
        Thread.sleep(1000);
    }
    configService.shutDown();
}
</code></pre>
<p>输出结果<br>
服务启动输出：<code>init configInfo: =&gt; demo.name=hello,name</code><br>
nacos修改配置后，输出：<code>receive configInfo: =&gt; demo.name=hello,new name</code></p>
<p>核心逻辑主要是getConfigAndSignListener（同addListener)，及对应Listener的receiveConfigInfo方法，nacos-server触发配置更新时，回调并传回最新配置信息，至于该方法拿到配置信息能做什么，那就看我们想做什么了</p>
<h2 id="关键类">关键类</h2>
<h3 id="nacosconfigservice">NacosConfigService</h3>
<p>客户端操作nacos-client-config的类，常用的操作有：获取最新配置信息、增加移除监听、发布和删除配置信息<br>
常用的两种获取实例方式：</p>
<pre><code>public static ConfigService createConfigService(Properties properties) throws NacosException {
    return ConfigFactory.createConfigService(properties);
}

public static ConfigService createConfigService(String serverAddr) throws NacosException {
    return ConfigFactory.createConfigService(serverAddr);
}
</code></pre>
<h3 id="clientworker">ClientWorker</h3>
<p>每个客户端实例内部存在一个ClientWorker单例对象，内部包含真正的配置信息同步逻辑</p>
<h3 id="httpagent">HttpAgent</h3>
<p>与nacos-server通信的代理类，封装接口交互相关的逻辑</p>
<h3 id="cachedata">CacheData</h3>
<p>dataId，group，namespace三个字段对应一个配置集主体，即对应一个CacheData，内部存储配置实体文本、配置校验md5等等。若一个客户端维护使用了多个配置集，也就是多个CacheData，会根据dataId，group，namespace生成key，存储到<code>ConcurrentHashMap&lt;String, CacheData&gt; cacheMap</code>，用于后续统一配置管理</p>
<p><b>CacheData创建过程</b><br>
<img src="https://voilaf.github.io/post-images/1647678704015.png" alt="" loading="lazy"></p>
<h3 id="listener">Listener</h3>
<p>每一个Listener对应绑定到一个CacheData，当一个CacheData的配置实体文本更新时，回调Listener使业务层感知并作出处理</p>
<p><b>addListener</b><br>
主要部分伪代码（此时本地</p>
<pre><code>CacheData cache = addCacheDataIfAbsent(dataId, group, tenant);
for (Listener listener : listeners) {
    cache.addListener(listener);
}
</code></pre>
<p>根据dataId, group, tenant获取或新增CacheData，并在CacheData内增加Listener</p>
<p><b>getConfigAndSignListener</b><br>
主要部分伪代码</p>
<pre><code>// 请求nacos-server获取配置信息
String content = getConfig(dataId, group, timeoutMs);

......

CacheData cache = addCacheDataIfAbsent(dataId, group, tenant);
cache.setContent(content);
for (Listener listener : listeners) {
    cache.addListener(listener);
}
</code></pre>
<h2 id="客户端长轮询">客户端长轮询</h2>
<p>创建LongPollingRunnable线程，不断&quot;自旋&quot;重复执行</p>
<p>请求判断指定配置集是否更新的接口头部参数说明：</p>
<table>
<thead>
<tr>
<th>请求头名</th>
<th>含义</th>
<th>示例值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Listening-Configs</td>
<td>指定配置集key</td>
<td>demo-data-idDEFAULT_GROUP</td>
</tr>
<tr>
<td>Long-Pulling-Timeout</td>
<td>长轮询超时等待时间</td>
<td>30000</td>
</tr>
<tr>
<td>Long-Pulling-Timeout-No-Hangup</td>
<td>长轮询时，无更新数据是否阻塞等待：&quot;true&quot;(不阻塞) &quot;fasle&quot;(阻塞)（新CacheData初始化时，值为true；默认情况值为false）</td>
<td>&quot;true&quot;</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1647698371914.png" alt="" loading="lazy"></figure>
<h1 id="server流程">server流程</h1>
<p>主要部分</p>
<h2 id="判断配置集是否更新">判断配置集是否更新</h2>
<p>核心是AsyncContext，'hold'客户端的请求句柄上下文，释放WebServer内的线程；将请求上下文作为变量传递到业务运行线程，并等待一定时间执行，若这个时间内结束，该上下文未被响应文本内容，则按该配置集未更新操作；若中间过程配置被更新，通过中间的事件监听转发，DataChangeTask内获取该请求上下文并响应客户端该配置集已更新<br>
<img src="https://voilaf.github.io/post-images/1647767443918.png" alt="" loading="lazy"></p>
<h1 id="两种接入方式的自动刷新">两种接入方式的自动刷新</h1>
<h2 id="nacos-config-spring-boot-starter">nacos-config-spring-boot-starter</h2>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
    &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;0.2.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>通常，我们对变量使用<code>@NacosValue</code>来注入配置值，若增加启动<code>autoRefreshed</code>(默认false关闭)，则实现配置的实时动态刷新，那么来找找解析的地方，定位两个问题</p>
<ol>
<li>NacosValue注解如何完成初次注入</li>
<li>打开autoRreshed选项如何完成实时动态刷新</li>
</ol>
<h3 id="nacosvalue注解如何完成初次注入">NacosValue注解如何完成初次注入</h3>
<p>Bean实例化完成后，会执行populateBean方法注入依赖项，针对BeanPostProcessor处理时，若为InstantiationAwareBeanPostProcessor类型，调用对应postProcessPropertyValues方法</p>
<p><b>关于InstantiationAwareBeanPostProcessor</b><br>
摘自 org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 部分注释内容</p>
<blockquote>
<p>......，or to implement additional injection strategies such as field injection</p>
</blockquote>
<p>Autowired和Value注解对应属性注入，依赖AutowiredAnnotationBeanPostProcessor类，也是InstantiationAwareBeanPostProcessor的一种实现</p>
<p>nacos对应InstantiationAwareBeanPostProcessor实现类：<b>NacosValueAnnotationBeanPostProcessor</b></p>
<p>类结构图<br>
<img src="https://voilaf.github.io/post-images/1647868288758.png" alt="" loading="lazy"></p>
<p>指定解析注解类型为：NacosValue</p>
<pre><code>public NacosValueAnnotationBeanPostProcessor() {
    super(NacosValue.class);
}
</code></pre>
<p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</code>调用<code>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#postProcessPropertyValues</code>方法，查找当前Bean是否存在NacosValue注解的属性，针对注解元数据回调<code>com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#doGetInjectedBean</code>获取对应的真实值，最后反射注入到Bean实例内的属性中</p>
<p>总结来说，每个Bean实例化后调用populateBean方法注入依赖，InstantiationAwareBeanPostProcessor类型的BeanPostProcessor，扫描Bean内是否存在对应注解，并根据自定义方法获取其注解对应属性的真实值，最后通过反射注入</p>
<h3 id="打开autorreshed选项如何完成实时动态刷新">打开autoRreshed选项如何完成实时动态刷新</h3>
<p>聚焦<code>com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#postProcessBeforeInitialization</code>，完成populateBean方法注入依赖后会触发。</p>
<p>相关代码：<br>
若NacosValue注解开启了autoRefreshed，会将Bean、属性、注解相关信息封装到NacosValueTarget类内，并存储到全局变量placeholderNacosValueTargetMap中</p>
<pre><code>private void doWithAnnotation(String beanName, Object bean, NacosValue annotation,
        int modifiers, Method method, Field field) {
        ......
        if (annotation.autoRefreshed()) {
            String placeholder = resolvePlaceholder(annotation.value());

            if (placeholder == null) {
                return;
            }

            NacosValueTarget nacosValueTarget = new NacosValueTarget(bean, beanName,
                    method, field, annotation.value());
            put2ListMap(placeholderNacosValueTargetMap, placeholder,
                    nacosValueTarget);
        }
    }
}
</code></pre>
<p>nacos配置信息修改后触发事件监听，遍历placeholderNacosValueTargetMap内元素，查找是否存在对应老配置，最后反射注入</p>
<pre><code>@Override
public void onApplicationEvent(NacosConfigReceivedEvent event) {
    // In to this event receiver, the environment has been updated the
    // latest configuration information, pull directly from the environment
    // fix issue #142
    for (Map.Entry&lt;String, List&lt;NacosValueTarget&gt;&gt; entry : placeholderNacosValueTargetMap
            .entrySet()) {
        String key = environment.resolvePlaceholders(entry.getKey());
        String newValue = environment.getProperty(key);

        if (newValue == null) {
            continue;
        }
        List&lt;NacosValueTarget&gt; beanPropertyList = entry.getValue();
        for (NacosValueTarget target : beanPropertyList) {
            String md5String = MD5Utils.md5Hex(newValue, &quot;UTF-8&quot;);
            boolean isUpdate = !target.lastMD5.equals(md5String);
            if (isUpdate) {
                target.updateLastMD5(md5String);
                Object evaluatedValue = resolveNotifyValue(target.nacosValueExpr, key, newValue);
                if (target.method == null) {
                    setField(target, evaluatedValue);
                }
                else {
                    setMethod(target, evaluatedValue);
                }
            }
        }
    }
}
</code></pre>
<h2 id="spring-cloud-starter-alibaba-nacos-config">spring-cloud-starter-alibaba-nacos-config</h2>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在SpringCloud内，对变量使用<code>@Value</code>注入配置值，对当前类使用<code>@RefreshScope</code>开启配置实时动态刷新</p>
<p>同样来定位两个问题</p>
<ol>
<li>Value注解如何完成初次注入</li>
<li>RefreshScope如何完成实时动态刷新</li>
</ol>
<h3 id="value注解如何完成初次注入">Value注解如何完成初次注入</h3>
<p>聚焦<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>，核心步骤同NacosValue解析过程</p>
<h3 id="refreshscope如何完成实时动态刷新">RefreshScope如何完成实时动态刷新</h3>
<p>RefreshScope注解含义</p>
<pre><code>@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Scope(&quot;refresh&quot;)
@Documented
public @interface RefreshScope {
	/**
	 * @see Scope#proxyMode()
	 * @return proxy mode
	 */
	ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;
}
</code></pre>
<p>我们知道，默认情况下Spring内部的Bean以singleton的scope注册，在<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>内部创建Bean区分了三种情况，分别是singleton、prototype、others，设置RefreshScope注解的Bean，通过RefreshScope类来创建Bean</p>
<p><b>配置更新逻辑</b><br>
spring-cloud-starter-alibaba-nacos-config启动时，NacosConfigAutoConfiguration加载创建NacosContextRefresher，监听ApplicationReadyEvent事件</p>
<p>ApplicationReadyEvent事件添加NacosConfigChangeListener，注册nacos配置更新监听</p>
<p>配置更新时，发布RefreshEvent事件</p>
<p>监听RefreshEvent处，将重置Environment环境，并清理RefreshScope内对应使用该配置的Bean，下次这些Bean被获取时将被重新创建</p>
<pre><code>public synchronized Set&lt;String&gt; refresh() {
    Set&lt;String&gt; keys = refreshEnvironment();
    this.scope.refreshAll();
    return keys;
}
</code></pre>
<p>因此，修改配置前后分别返回以下控制器方法，会发现除了username值变动以外，Bean对应的地址也修改了</p>
<pre><code>@RestController
@RefreshScope
public class IndexController {

    @Value(&quot;${business.username:local}&quot;)
    private String username;

    @GetMapping(&quot;/index&quot;)
    public String index() {
        return username + &quot; | &quot; + this;
    }
}
</code></pre>
<h3 id="一个不经意可能会发生的问题">一个不经意可能会发生的问题</h3>
<p>通过上述说明，基于spring-cloud-starter-alibaba-nacos-config包的配置动态刷新，会重建Bean实例</p>
<p>通常，我们喜欢让类实现一些接口来做一些初始化操作，如InitializingBean、CommandLineRunner、ApplicationRunner等等。</p>
<p><b>CommandLineRunner、ApplicationRunner触发点</b><br>
org.springframework.boot.SpringApplication#run(java.lang.String...)`方法内，整个服务的生命周期里只会调用一次<br>
<b>InitializingBean触发点</b><br>
Bean实例化时调用，一旦涉及到Bean的重建，对应的afterPropertiesSet方法会被重复触发，若只是做一些固定的查询、赋值操作，那当然没问题，如果不小心在此处创建了守护线程等长生命周期的资源，将会导致资源浪费和业务异常</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[try-with-resources and finally binary code]]></title>
        <id>https://voilaf.github.io/post/try-with-resources-and-finally-binary-code/</id>
        <link href="https://voilaf.github.io/post/try-with-resources-and-finally-binary-code/">
        </link>
        <updated>2022-03-14T13:03:55.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%9B%AE%E7%9A%84">目的</a></li>
<li><a href="#java%E7%89%88%E6%9C%AC">Java版本</a></li>
<li><a href="#%E5%85%AC%E5%85%B1%E7%B1%BBlocalresource">公共类LocalResource</a></li>
<li><a href="#finally%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90">finally情况分析</a>
<ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90%E4%B8%80">例子一</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%BA%90%E4%BB%A3%E7%A0%81">测试源代码</a></li>
<li><a href="#class%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E4%BB%A3%E7%A0%81">class文件反编代码</a></li>
<li><a href="#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81">对应字节码</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0">结果描述</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E5%AD%90%E4%BA%8C">例子二</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%BA%90%E4%BB%A3%E7%A0%81-2">测试源代码</a></li>
<li><a href="#class%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E4%BB%A3%E7%A0%81-2">class文件反编代码</a></li>
<li><a href="#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81-2">对应字节码</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E8%A1%A8">异常表</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0-2">结果描述</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E5%AD%90%E4%B8%89">例子三</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%BA%90%E4%BB%A3%E7%A0%81-3">测试源代码</a></li>
<li><a href="#class%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E4%BB%A3%E7%A0%81-3">class文件反编代码</a></li>
<li><a href="#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81-3">对应字节码</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E8%A1%A8-2">异常表</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0-3">结果描述</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#try-with-resources%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90">try-with-resources情况分析</a>
<ul>
<li><a href="#%E5%90%AB%E4%B9%89-2">含义</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsuppressed-exception">什么是suppressed exception</a></li>
<li><a href="#%E9%99%B7%E5%85%A5%E6%80%9D%E7%BB%B4%E7%9A%84%E5%9D%91">陷入思维的坑</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90%E4%B8%80-2">例子一</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%BA%90%E4%BB%A3%E7%A0%81-4">测试源代码</a></li>
<li><a href="#class%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E4%BB%A3%E7%A0%81-4">class文件反编代码</a></li>
<li><a href="#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81-4">对应字节码</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0-4">结果描述</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E5%AD%90%E4%BA%8C-2">例子二</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%BA%90%E4%BB%A3%E7%A0%81-5">测试源代码</a></li>
<li><a href="#class%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E4%BB%A3%E7%A0%81-5">class文件反编代码</a></li>
<li><a href="#%E5%AF%B9%E5%BA%94%E5%AD%97%E8%8A%82%E7%A0%81-5">对应字节码</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E8%A1%A8-3">异常表</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0-5">结果描述</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="目的">目的</h1>
<p>关于两个功能的字节码实现分析</p>
<h1 id="java版本">Java版本</h1>
<p>JDK：1.8.x</p>
<h1 id="公共类localresource">公共类LocalResource</h1>
<p>主要是实现了AutoCloseable，用于后续实现try-with-resources语法糖</p>
<pre><code>public class LocalResource implements AutoCloseable {

    public void handle() {
        System.out.println(&quot;handle&quot;);
    }

    @Override
    public void close() throws Exception {
        System.out.println(&quot;close&quot;);
    }
}
</code></pre>
<h1 id="finally情况分析">finally情况分析</h1>
<h2 id="含义">含义</h2>
<p>摘自 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html">https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html</a></p>
<blockquote>
<p>The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling — it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.</p>
</blockquote>
<p>确保必须执行的代码（如：资源释放）能够保证被执行，避免被return、break、throw等等语句终止</p>
<h2 id="例子一">例子一</h2>
<h3 id="测试源代码">测试源代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    try {
    } finally {
        localResource.close();
    }
}
</code></pre>
<h3 id="class文件反编代码">class文件反编代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    localResource.close();
}
</code></pre>
<h3 id="对应字节码">对应字节码</h3>
<pre><code> 0 new #2 &lt;LocalResource&gt;
 3 dup
 4 invokespecial #3 &lt;LocalResource.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aload_1
 9 invokevirtual #4 &lt;LocalResource.close : ()V&gt;
12 return
</code></pre>
<h3 id="结果描述">结果描述</h3>
<p>该例子try-finally是无效的<br>
字节码和反编代码都很清晰展示了仅实例化LocalResource对象并调用close方法</p>
<h2 id="例子二">例子二</h2>
<h3 id="测试源代码-2">测试源代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    try {
        localResource.handle();
    } finally {
        localResource.close();
    }
}
</code></pre>
<h3 id="class文件反编代码-2">class文件反编代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    try {
        localResource.handle();
    } finally {
        localResource.close();
    }
}
</code></pre>
<h3 id="对应字节码-2">对应字节码</h3>
<pre><code> 0 new #2 &lt;LocalResource&gt;
 3 dup
 4 invokespecial #3 &lt;LocalResource.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aload_1
 9 invokevirtual #4 &lt;LocalResource.handle : ()V&gt;
12 aload_1
13 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
16 goto 26 (+10)
19 astore_2
20 aload_1
21 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
24 aload_2
25 athrow
26 return
</code></pre>
<h3 id="异常表">异常表</h3>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>起始PC</th>
<th>结束PC</th>
<th>跳转PC</th>
<th>捕获类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8</td>
<td>12</td>
<td>19</td>
<td>cp_info #0 <br />any</td>
</tr>
</tbody>
</table>
<h3 id="结果描述-2">结果描述</h3>
<p>该例子中的反编代码没啥内容，对照异常表来看字节码部分</p>
<blockquote>
<p>0 new #2 <LocalResource><br>
3 dup<br>
4 invokespecial #3 &lt;LocalResource.<init> : ()V&gt;<br>
7 astore_1</p>
</blockquote>
<p>常规部分，初始化LocalResource对象调用初始化方法后，将类变量存储到本地变量表索引1的位置</p>
<blockquote>
<p>8 aload_1<br>
9 invokevirtual #4 &lt;LocalResource.handle : ()V&gt;</p>
</blockquote>
<p>此处表示调用LocalResource类的handle方法，由于调用其他类的方法，并不能保证不会抛出异常，所以异常表定义了若存在异常，将开始执行偏移量19位置及其后续的字节码。<br>
<b>注意：9后面是12,12并不包含在异常监控范围内</b></p>
<blockquote>
<p>19 astore_2<br>
20 aload_1<br>
21 invokevirtual #5 &lt;LocalResource.close : ()V&gt;<br>
24 aload_2<br>
25 athrow</p>
</blockquote>
<p>将handle方法抛出的异常存储到本地变量表下标2的位置，从下标1中取出LocalResource变量执行close方法，重取出异常并抛出，既完成程序执行</p>
<blockquote>
<p>12 aload_1<br>
13 invokevirtual #5 &lt;LocalResource.close : ()V&gt;<br>
16 goto 26 (+10)<br>
26 return</p>
</blockquote>
<p>这是handle方法不抛出异常的执行分支，则正常取出LocalResource类变量，调用close方法后，return正常完成程序执行</p>
<p>综上所述，通过区分有异常和无异常的情况，各自插入close方法的执行字节码，确保每个分支都能执行</p>
<h2 id="例子三">例子三</h2>
<h3 id="测试源代码-3">测试源代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    try {
        localResource.handle();
        throw new RuntimeException(&quot;runtime&quot;);
    } finally {
        localResource.close();
    }
}
</code></pre>
<h3 id="class文件反编代码-3">class文件反编代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    try {
        localResource.handle();
        throw new RuntimeException(&quot;runtime&quot;);
    } finally {
        localResource.close();
    }
}
</code></pre>
<h3 id="对应字节码-3">对应字节码</h3>
<pre><code> 0 new #2 &lt;LocalResource&gt;
 3 dup
 4 invokespecial #3 &lt;LocalResource.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aload_1
 9 invokevirtual #4 &lt;LocalResource.handle : ()V&gt;
12 new #5 &lt;java/lang/RuntimeException&gt;
15 dup
16 ldc #6 &lt;runtime&gt;
18 invokespecial #7 &lt;java/lang/RuntimeException.&lt;init&gt; : (Ljava/lang/String;)V&gt;
21 athrow
22 astore_2
23 aload_1
24 invokevirtual #8 &lt;LocalResource.close : ()V&gt;
27 aload_2
28 athrow
</code></pre>
<h3 id="异常表-2">异常表</h3>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>起始PC</th>
<th>结束PC</th>
<th>跳转PC</th>
<th>捕获类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8</td>
<td>23</td>
<td>22</td>
<td>cp_info #0 <br />any</td>
</tr>
</tbody>
</table>
<h3 id="结果描述-3">结果描述</h3>
<p>同样直接来看字节码</p>
<blockquote>
<p>0 new #2 <LocalResource><br>
3 dup<br>
4 invokespecial #3 &lt;LocalResource.<init> : ()V&gt;<br>
7 astore_1<br>
8 aload_1<br>
9 invokevirtual #4 &lt;LocalResource.handle : ()V&gt;<br>
12 new #5 &lt;java/lang/RuntimeException&gt;<br>
15 dup<br>
16 ldc #6 <runtime><br>
18 invokespecial #7 &lt;java/lang/RuntimeException.<init> : (Ljava/lang/String;)V&gt;<br>
21 athrow</p>
</blockquote>
<p>这是一路向前没有分支的逻辑，初始化LocalResource类变量并执行handle方法，再初始化一个Runtime异常直接抛出<br>
对照异常表，抛出异常后开始执行22位置的字节码</p>
<blockquote>
<p>22 astore_2<br>
23 aload_1<br>
24 invokevirtual #8 &lt;LocalResource.close : ()V&gt;<br>
27 aload_2<br>
28 athrow</p>
</blockquote>
<p>将异常存储到本地变量表下标2位置，执行LocalResource的close方法，重取出异常并抛出完成程序执行</p>
<p>综上所述，Java源代码中的异常，下沉到字节码，其实没有那么的粗暴，存在一定的操作粒度，异常触发后的逻辑是可控的</p>
<h1 id="try-with-resources情况分析">try-with-resources情况分析</h1>
<h2 id="含义-2">含义</h2>
<p>摘自 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html</a></p>
<blockquote>
<p>The try-with-resources statement is a try statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.</p>
</blockquote>
<p>try语句块内可以定义一或者多个资源，通过try-with-resources语法糖，可以让编写者忽略资源释放逻辑，编译器会隐式的在字节码添加资源关闭的代码</p>
<h2 id="什么是suppressed-exception">什么是suppressed exception</h2>
<p>举个例子</p>
<pre><code>public static void main(String[] args) throws Exception {
    try {
        // invoke methodA and throw exception 123
        // mock
        throw new RuntimeException(&quot;123&quot;);
    } finally {
        // invoke methodClose and throw exception 321
        // mock
        throw new RuntimeException(&quot;321&quot;);
    }
}
</code></pre>
<p>执行结果：<code>Exception in thread &quot;main&quot; java.lang.RuntimeException: 321 	at Application.main(Application.java:22)</code></p>
<p>try块内的异常信息被后置调用的finally块异常覆盖了。一般情况下，我们会更关注try块内的逻辑和异常。<br>
这就是suppressed exception的作用，聚焦真正有用的异常信息（并不是抛掉finally内资源释放的异常，而是突出重点）</p>
<p>再来看个例子</p>
<pre><code>public static void main(String[] args) throws Exception {
    Throwable throwable = null;
    try {
        // invoke methodA and throw exception 123
        // mock
        throw new RuntimeException(&quot;123&quot;);
    } catch (Exception e) {
        throwable = e;
        throw e;
    } finally {
        // invoke methodClose and throw exception 321
        // mock
        RuntimeException runtimeException = new RuntimeException(&quot;321&quot;);
        if (throwable == null) {
            throw runtimeException;
        } else {
            throwable.addSuppressed(runtimeException);
        }
    }
}
</code></pre>
<p>执行结果：<code>Exception in thread &quot;main&quot; java.lang.RuntimeException: 123 	at Application.main(Application.java:22) 	Suppressed: java.lang.RuntimeException: 321 		at Application.main(Application.java:29)</code></p>
<p>定义一个Throwable变量去指向业务逻辑的有意义异常，相对优先级低点的异常通过调用addSuppressed方法存储起来，忽略该异常的throw逻辑</p>
<p>其实严格意义上并不是专门讲suppressed exception的，更倾向是try-with-resources的使用<br>
可以参考：<a href="https://stackoverflow.com/questions/7849416/what-is-a-suppressed-exception">https://stackoverflow.com/questions/7849416/what-is-a-suppressed-exception</a></p>
<h2 id="陷入思维的坑">陷入思维的坑</h2>
<p>下面的例子中，会出现<code>aconst_null</code> 和 <code>astore_x</code>连续的字节码，起初苦思不得，另外吐槽下搜索try-with-resources字节码的文章，也许姿势不对，大部分都是&quot;字节码层面实现了资源释放&quot;一句带过，感觉这篇文章的点醒（<a href="https://emacsist.github.io/2020/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://emacsist.github.io/2020/05/25/深入理解jvm字节码读书笔记/</a>），让我反应过来回过头去看反编的源代码</p>
<h2 id="例子一-2">例子一</h2>
<h3 id="测试源代码-4">测试源代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    try(LocalResource localResource = new LocalResource()) {

    }
}
</code></pre>
<h3 id="class文件反编代码-4">class文件反编代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    Object var2 = null;
    if (localResource != null) {
        if (var2 != null) {
            try {
                localResource.close();
            } catch (Throwable var4) {
                ((Throwable)var2).addSuppressed(var4);
            }
        } else {
            localResource.close();
        }
    }
}
</code></pre>
<h3 id="对应字节码-4">对应字节码</h3>
<pre><code> 0 new #2 &lt;LocalResource&gt;
 3 dup
 4 invokespecial #3 &lt;LocalResource.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aconst_null
 9 astore_2
10 aload_1
11 ifnull 38 (+27)
14 aload_2
15 ifnull 34 (+19)
18 aload_1
19 invokevirtual #4 &lt;LocalResource.close : ()V&gt;
22 goto 38 (+16)
25 astore_3
26 aload_2
27 aload_3
28 invokevirtual #6 &lt;java/lang/Throwable.addSuppressed : (Ljava/lang/Throwable;)V&gt;
31 goto 38 (+7)
34 aload_1
35 invokevirtual #4 &lt;LocalResource.close : ()V&gt;
38 return
</code></pre>
<h3 id="结果描述-4">结果描述</h3>
<p>这个例子并不复杂，甚至还有点奇怪，class文件反编代码里var2没有赋值操作，为什么还有判断是否为空（例子二解惑）？另外，只看测试源代码和字节码，怎么都想不明白8、9的作用，只能根据上下文26、27得出这是存储了一个Throwable的变量（同样，例子二解惑）</p>
<h2 id="例子二-2">例子二</h2>
<p>例子一解惑：因为例子一是脱离于实际的不完整代码~，try块内无有意义的业务代码，这一般不会发生</p>
<h3 id="测试源代码-5">测试源代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    try(LocalResource localResource = new LocalResource()) {
        // 模拟增加业务处理
        localResource.handle();
    }
}
</code></pre>
<h3 id="class文件反编代码-5">class文件反编代码</h3>
<pre><code>public static void main(String[] args) throws Exception {
    LocalResource localResource = new LocalResource();
    Throwable var2 = null;
    try {
        localResource.handle();
    } catch (Throwable var11) {
        var2 = var11;
        throw var11;
    } finally {
        if (localResource != null) {
            if (var2 != null) {
                try {
                    localResource.close();
                } catch (Throwable var10) {
                    var2.addSuppressed(var10);
                }
            } else {
                localResource.close();
            }
        }
    }
}
</code></pre>
<h3 id="对应字节码-5">对应字节码</h3>
<pre><code> 0 new #2 &lt;LocalResource&gt;
 3 dup
 4 invokespecial #3 &lt;LocalResource.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aconst_null
 9 astore_2
10 aload_1
11 invokevirtual #4 &lt;LocalResource.handle : ()V&gt;
14 aload_1
15 ifnull 85 (+70)
18 aload_2
19 ifnull 38 (+19)
22 aload_1
23 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
26 goto 85 (+59)
29 astore_3
30 aload_2
31 aload_3
32 invokevirtual #7 &lt;java/lang/Throwable.addSuppressed : (Ljava/lang/Throwable;)V&gt;
35 goto 85 (+50)
38 aload_1
39 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
42 goto 85 (+43)
45 astore_3
46 aload_3
47 astore_2
48 aload_3
49 athrow
50 astore 4
52 aload_1
53 ifnull 82 (+29)
56 aload_2
57 ifnull 78 (+21)
60 aload_1
61 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
64 goto 82 (+18)
67 astore 5
69 aload_2
70 aload 5
72 invokevirtual #7 &lt;java/lang/Throwable.addSuppressed : (Ljava/lang/Throwable;)V&gt;
75 goto 82 (+7)
78 aload_1
79 invokevirtual #5 &lt;LocalResource.close : ()V&gt;
82 aload 4
84 athrow
85 return
</code></pre>
<h3 id="异常表-3">异常表</h3>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>起始PC</th>
<th>结束PC</th>
<th>跳转PC</th>
<th>捕获类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>22</td>
<td>26</td>
<td>29</td>
<td>cp_info #6 <br />java/lang/Throwable</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>14</td>
<td>45</td>
<td>cp_info #6 <br />java/lang/Throwable</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>14</td>
<td>50</td>
<td>cp_info #0 <br />any</td>
</tr>
<tr>
<td>3</td>
<td>60</td>
<td>64</td>
<td>67</td>
<td>cp_info #6 <br />java/lang/Throwable</td>
</tr>
<tr>
<td>4</td>
<td>45</td>
<td>52</td>
<td>50</td>
<td>cp_info #0 <br />any</td>
</tr>
</tbody>
</table>
<h3 id="结果描述-5">结果描述</h3>
<p>由于语法糖的存在，测试编写的源代码经编译后面目全非，聚焦class文件反编代码和字节码、异常表</p>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1647349207530.png" alt="" loading="lazy"></figure>
<p>注意两个红框内容，从逻辑上来看这两处是没有意义的（也许是我没看出来，但是不像），至于为什么会是这样的结果，强行从表面来解释的话，是因为finally里的代码是共用的...</p>
<h1 id="总结">总结</h1>
<p>try-with-resources 和 finally 其实都是在字节码层，判断种种执行分支，增加各种兜底处理，确保我们一定想要执行的代码，在哪个分支下都存在，同时复杂的地方在于要兼容各种异常情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thread-pool-executor]]></title>
        <id>https://voilaf.github.io/post/thread-pool-executor/</id>
        <link href="https://voilaf.github.io/post/thread-pool-executor/">
        </link>
        <updated>2022-03-12T07:03:14.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%9B%AE%E7%9A%84">目的</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%84%8F%E4%B9%89">线程池的意义</a></li>
<li><a href="#threadpoolexecutor-%E4%BB%8B%E7%BB%8D">ThreadPoolExecutor 介绍</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0">初始化过程相关参数</a></li>
<li><a href="#core-and-maximum-pool-sizes">Core and maximum pool sizes</a></li>
<li><a href="#on-demand-construction">On-demand construction</a></li>
<li><a href="#creating-new-threads">Creating new threads</a></li>
<li><a href="#keep-alive-times">Keep-alive times</a></li>
<li><a href="#queuing">Queuing</a></li>
<li><a href="#rejected-tasks">Rejected tasks</a></li>
<li><a href="#hook-methods">Hook methods</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E7%BB%93%E6%9E%84">类结构</a>
<ul>
<li><a href="#interface-executor">interface Executor</a></li>
<li><a href="#interface-executorservice">interface ExecutorService</a></li>
<li><a href="#abstract-class-abstractexecutorservice">abstract class AbstractExecutorService</a></li>
<li><a href="#class-threadpoolexecutor">class ThreadPoolExecutor</a>
<ul>
<li><a href="#inner-class-worker">inner class Worker</a></li>
</ul>
</li>
<li><a href="#class-executors">class Executors</a></li>
</ul>
</li>
<li><a href="#%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7">状态属性</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95">状态方法</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C">线程池运行</a>
<ul>
<li><a href="#execute%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4">execute方法执行步骤</a></li>
<li><a href="#addworker%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4">addWorker方法执行步骤</a>
<ul>
<li><a href="#reentrantlock-mainlock">ReentrantLock mainLock</a></li>
<li><a href="#worker%E7%B1%BB">Worker类</a></li>
<li><a href="#hashsetworker-workers">HashSet<Worker> workers</a></li>
</ul>
</li>
<li><a href="#shutdown-%E5%92%8C-shutdownnow-%E7%9A%84%E5%8C%BA%E5%88%AB">shutdown 和 shutdownNow 的区别</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%E5%90%8E%E7%9A%84%E5%8F%8D%E5%BA%94%E7%8E%B0%E8%B1%A1">运行中的线程池，修改参数后的反应现象</a>
<ul>
<li><a href="#corepoolsize">corePoolSize</a></li>
<li><a href="#maximumpoolsize">maximumPoolSize</a></li>
<li><a href="#keepalivetime">keepAliveTime</a></li>
<li><a href="#threadfactory">threadFactory</a></li>
<li><a href="#rejectedexecutionhandler">rejectedExecutionHandler</a></li>
</ul>
</li>
<li><a href="#submit">submit</a></li>
</ul>
</p>
<h1 id="目的">目的</h1>
<p>探索运行中的线程池，修改参数后的反应现象</p>
<h1 id="线程池的意义">线程池的意义</h1>
<p>每个线程池维护一些基本的统计信息，如完成的任务数，另外，线程池定位解决两个问题：</p>
<ol>
<li>将每个任务与线程如何执行、调度解耦，不需要去显示创建线程</li>
<li>执行大量异步任务时，由于减少了每个任务的调用开销（线程不用重复创建），可以很有效的提高性能</li>
<li>提供了限制和管理资源的方法，目标对象包括线程、消费的任务等</li>
</ol>
<h1 id="threadpoolexecutor-介绍">ThreadPoolExecutor 介绍</h1>
<p>PS：类注释写的非常好，说明了类的作用和各个参数之间的关系</p>
<h2 id="初始化过程相关参数">初始化过程相关参数</h2>
<table>
<thead>
<tr>
<th>parameter</th>
<th>default value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int corePoolSize</td>
<td></td>
<td>Core pool size is the minimum number of workers to keep alive (and not allow to time out etc) unless allowCoreThreadTimeOut is set, in which case the minimum is zero.</td>
</tr>
<tr>
<td>int maximumPoolSize</td>
<td></td>
<td>Maximum pool size. Note that the actual maximum is internally bounded by CAPACITY.</td>
</tr>
<tr>
<td>long keepAliveTime</td>
<td></td>
<td>Timeout in nanoseconds for idle threads waiting for work. Threads use this timeout when there are more than corePoolSize present or if allowCoreThreadTimeOut. Otherwise they wait forever for new work.</td>
</tr>
<tr>
<td>BlockingQueue<Runnable> workQueue</td>
<td></td>
<td>The queue used for holding tasks and handing off to worker threads.</td>
</tr>
<tr>
<td>ThreadFactory threadFactory</td>
<td>new DefaultThreadFactory()</td>
<td>Factory for new threads. All threads are created using this factory (via method addWorker).</td>
</tr>
<tr>
<td>RejectedExecutionHandler handler</td>
<td>new AbortPolicy()</td>
<td>Handler called when saturated or shutdown in execute.</td>
</tr>
</tbody>
</table>
<h2 id="core-and-maximum-pool-sizes">Core and maximum pool sizes</h2>
<p>线程池将根据corePoolSize和maximumPoolSize两个绑定的值，动态自动调整池子内的线程数量。<br>
投递一个新任务时，如果当前仅存在比corePoolSize小的线程数正在运行，一个新线程Worker将会被创建来处理该任务，即便其他的Worker处于空闲状态；如果存在比corePoolSize大，比maximum小的线程池正在运行，若此时queue已满，将创建新的线程Worker。<br>
将corePoolSize和maximum的值调整一样，我们将得到一个固定大小的线程池。若设置maximum为Integer.MAX_VALUE，线程池将能够处理任意数量的任务。通常情况下，这两个参数在构造阶段被设置，但是也可以使用setCorePoolSize和setMaximumPoolSize方法动态修改值。<br>
<img src="https://voilaf.github.io/post-images/1647070731000.png" alt="" loading="lazy"></p>
<h2 id="on-demand-construction">On-demand construction</h2>
<p>默认情况下，线程池只有任务被投递时，才会开始创建core线程，但是实际上可以动态调用prestartCoreThread或者prestartAllCoreThreads方法选择创建一个或者所有的core线程。若创建线程池时传入的队列非空已有任务，该操作会很有效。</p>
<h2 id="creating-new-threads">Creating new threads</h2>
<p>线程池内通过ThreadFactory创建线程，若没有显示指定，默认使用Executors.defaultThreadFactory，使用相同的ThreadGroup、优先级，非daemon模式。我们可以使用自实现的ThreadFactory，指定thread's name，thread group，priority，daemon status等等。</p>
<h2 id="keep-alive-times">Keep-alive times</h2>
<p>如果线程池当前存在超过corePoolSize的线程，并且超出的线程连续空闲超过keepAliveTime时间，这部分线程将变成terminated状态。当线程池不再活跃的被使用时，这将减少资源的消耗。如果后续线程池重新活跃，将会创建新的线程。setKeepALiveTime方法动态调整该参数。使用Long.MAX_VALUE可以防止空闲线程退出。默认情况下，keep-alive策略只针对超出corePoolSize的非core线程有效，但是如果调用了allowCoreThreadTimeOut(true)，且keepAliveTime值大于0，将使core线程也生效。</p>
<h2 id="queuing">Queuing</h2>
<p>每个队列都可能被用来转移和持有投递的任务。<br>
有三种相关的队列使用方式：</p>
<ol>
<li>如果比corePoolSize小的线程正在运行，线程池将新增一个新的线程执行任务而不是将任务投递到队列</li>
<li>如果corePoolSize或者更多的线程正在运行，线程池将把任务投递到队列而不是新增线程</li>
<li>如果一个任务不能投递到队列，若此时线程数小于maximum，新增线程；否则任务将被拒绝<br>
有三种队列常用的策略：</li>
<li>直接交付。如SynchrnousQueue，该队列并不会持有任务，而不是直接转交给线程</li>
<li>无界队列。如LinkedBlockingQueue（初始化时未指定容量），当corePoolSize对应的线程忙碌状态时，所有新投递的任务都会被投递到队列中排队，直到有core线程空闲，此时maximumPoolSize值没有意义，不会额外创建线程</li>
<li>有界队列。如ArrayBlockingQueue，设置有限的maximumPoolSize值，可以有效防止资源耗尽，但是这会很难控制，队列容量和maximumPoolSize得做出均衡：使用大的队列容量和小的maximumPoolSize可以减少CPU使用、系统资源和上下文切换负荷，但是吞吐量会减少，既任务执行的慢了。如果任务频繁的堵塞（比如IO密集型任务），系统可能能够有比预想更多的时间去调度线程。使用小的队列通常要求更大的线程池，会导致CPU更繁忙，但是可能会碰到不可接受的调度开销，也会使吞吐量减少。</li>
</ol>
<h2 id="rejected-tasks">Rejected tasks</h2>
<p>当线程池已被shutdown或者有边界（已到达最大线程池和队列已饱和），投递任务将被拒绝。<br>
默认已预定义了四种拒绝策略：</p>
<ol>
<li>默认选择策略：AbortPolicy。拒绝任务时会抛出一个Runtime异常（RejectedExecutionException）</li>
<li>CallerRunsPolicy。投递任务的线程本身会同步执行该任务，任务执行从异步变成同步，会影响正常的业务响应</li>
<li>DiscardPolicy。投递的任务将会被丢弃，忽略不再执行</li>
<li>DiscardOldestPolicy。如果线程池未被shutdown，在队列头部的任务（最先投递）将被丢弃，并重新投递当前任务</li>
</ol>
<h2 id="hook-methods">Hook methods</h2>
<p>可以继承ThreadPoolExecutor类重写beforeExecute(Thread, Runnable)和afterExecute(Runnable, Throwable)方法，在每一个任务执行前后，增加hook</p>
<h1 id="类结构">类结构</h1>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1647068674907.png" alt="" loading="lazy"></figure>
<h2 id="interface-executor">interface Executor</h2>
<p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. However, the Executor interface does not strictly require that execution be asynchronous.</p>
<h2 id="interface-executorservice">interface ExecutorService</h2>
<p>ExecutorService implements Executor，it is a more extensive interface. An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.</p>
<h2 id="abstract-class-abstractexecutorservice">abstract class AbstractExecutorService</h2>
<p>Provides default implementations of ExecutorService execution methods. This class implements the submit, invokeAny and invokeAll methods using a RunnableFuture returned by newTaskFor, which defaults to the FutureTask class provided in this package.</p>
<h2 id="class-threadpoolexecutor">class ThreadPoolExecutor</h2>
<p>An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods.</p>
<h3 id="inner-class-worker">inner class Worker</h3>
<p>Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping.<br>
Worker类继承AbstractQueuedSynchronizer，以便于在每个任务执行时，可以简化获取和释放锁的操作，这可以防止中断时去唤醒等待任务的线程而不是一个正在执行任务的线程。另外，不使用ReentrantLock而是单独实现一个简单的排他锁是因为当线程控制方法被调用时（比如setCorePoolSize），worker不会重复的获取锁。</p>
<h2 id="class-executors">class Executors</h2>
<p>该类并不与上述几个类有直接关系，但是往往会伴随使用。<br>
Factory and utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes defined in this package. This class supports the following kinds of methods:<br>
Methods that create and return an ExecutorService set up with commonly useful configuration settings.</p>
<ul>
<li>Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings.</li>
<li>Methods that create and return a &quot;wrapped&quot; ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.</li>
<li>Methods that create and return a ThreadFactory that sets newly created threads to a known state.</li>
<li>Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable.</li>
</ul>
<h1 id="状态属性">状态属性</h1>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
</code></pre>
<blockquote>
<p>The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc In order to pack them into one int.</p>
</blockquote>
<blockquote>
<p>The workerCount is the number of workers that have been permitted to start and not permitted to stop.</p>
</blockquote>
<blockquote>
<p>The runState provides the main lifecycle control, taking on values: RUNNING: Accept new tasks and process queued tasks<br>
SHUTDOWN: Don't accept new tasks, but process queued tasks<br>
STOP: Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks<br>
TIDYING: All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method TERMINATED: terminated() has completed The numerical order among these values matters, to allow ordered comparisons.</p>
</blockquote>
<p>CAPACITY二进制表示：      0001 1111 1111 1111 1111 1111 1111 1111<br>
RUNNING二进制表示：     1110 0000 0000 0000 0000 0000 0000 0000 &lt; 0<br>
SHUTDOWN二进制表示： 0000 0000 0000 0000 0000 0000 0000 0000 = 0<br>
STOP二进制表示：             0010 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
TIDYING二进制表示：        0100 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
TERMINATED二进制表示：0110 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
数值大于对比：RUNNING &lt; SHUTODWN &lt; STOP &lt; TIDYING &lt; TERMINATED<br>
PS：数值关系是isRunning、runStateAtLeast、runStateLessThan等状态相关方法成立的前提，线程池的状态流程是一个递进的关系</p>
<h1 id="状态方法">状态方法</h1>
<pre><code>// Packing and unpacking ctl
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>~CAPACITY有效位：1110 0000 0000 0000 0000 0000 0000 0000<br>
runStateOf方法获取线程池的运行状态<br>
workerCountOf方法获取线程池当前线程数量<br>
ctlOf方法或操作将线程池运行状态和线程池线程数量合并到一个整型变量</p>
<h1 id="线程池运行">线程池运行</h1>
<pre><code>public static void main(String[] args) {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(1));
    executor.execute(() -&gt; System.out.println(Thread.currentThread().getName()));
    executor.shutdown();
}
</code></pre>
<p>这是最常见的demo，创建了一个线程池，corePoolSize为5，maximumPoolSize为10，队列类型为LinkedBlockingQueue且容量为1。<br>
execute方法投递一个Runnable并等待执行。<br>
shutdown方法终止线程池。</p>
<h2 id="execute方法执行步骤">execute方法执行步骤</h2>
<blockquote>
<p>Proceed in 3 steps:</p>
<ol>
<li>If fewer than corePoolSize threads are running, try to<br>
start a new thread with the given command as its first<br>
task.  The call to addWorker atomically checks runState and<br>
workerCount, and so prevents false alarms that would add<br>
threads when it shouldn't, by returning false.<br>
当前存在corePoolSize个线程正在运行，添加一个新线程，并将该任务作为新线程的第一个任务，存储到内部参数里，而不会去队列内获取任务。addWorker方法可能会创建线程失败并返回false。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>If a task can be successfully queued, then we still need<br>
to double-check whether we should have added a thread<br>
(because existing ones died since last checking) or that<br>
the pool shut down since entry into this method. So we<br>
recheck state and if necessary roll back the enqueuing if<br>
stopped, or start a new thread if there are none.<br>
如果成功投递一个任务到队列中，我们需要二次检查判断当前线程池中是否存在活跃线程（如：corePoolSize等于0；或二次检查前活跃线程退出；或线程池非Running状态，将不再接受新任务）。选择从队列取出任务并reject或新创建线程。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>If we cannot queue task, then we try to add a new<br>
thread.  If it fails, we know we are shut down or saturated<br>
and so reject the task.<br>
如果队列无法投递任务，则去创建新的非core线程，若创建失败表示线程池非Running或资源已经饱和并reject。</li>
</ol>
</blockquote>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://voilaf.github.io/post-images/1647163442793.png" alt="" loading="lazy"></figure>
<h2 id="addworker方法执行步骤">addWorker方法执行步骤</h2>
<p>第一个for循环判断线程池的运行状态<br>
第二个for循环判断线程数是否符合条件并且CAS更新ctl</p>
<pre><code>private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        ......
        for (;;) {
            ......
        }
    }
}
</code></pre>
<p>检查运行状态：非RUNNING状态时，仅指定SHUTDOWN状态并且非投递任务、队列非空才创建线程</p>
<pre><code>// Check if queue empty only if necessary.
if (rs &gt;= SHUTDOWN &amp;&amp;
    ! (rs == SHUTDOWN &amp;&amp;
        firstTask == null &amp;&amp;
        ! workQueue.isEmpty()))
    return false;
</code></pre>
<p>创建core线程时，判断当前线程数是否已大于corePoolSize<br>
创建非core线程时，判断当前线程数是否已大于maximumPoolSize</p>
<pre><code>int wc = workerCountOf(c);
if (wc &gt;= CAPACITY ||
    wc &gt;= (core ? corePoolSize : maximumPoolSize))
    return false;
</code></pre>
<p>CAS操作ctl变量，线程数计数加1，增加成功则全局状态设置完成，退出两个for循环，进行剩余的线程初始化工作</p>
<pre><code>if (compareAndIncrementWorkerCount(c))
    break retry;
</code></pre>
<p>判断线程池状态是否变动，变动则重新执行第一个for循环进行线程池状态判断</p>
<pre><code>c = ctl.get();  // Re-read ctl
if (runStateOf(c) != rs)
    continue retry;
</code></pre>
<h3 id="reentrantlock-mainlock">ReentrantLock mainLock</h3>
<blockquote>
<p>Lock held on access to workers set and related bookkeeping.<br>
It also simplifies some of the associated statistics bookkeeping of largestPoolSize etc.</p>
</blockquote>
<p>根据mainLock的注释来看，是为了加锁处理Worker相关的设置和一些统计等，避免不必要的中断<br>
个别使用场景有：</p>
<ol>
<li>Worker内线程进行中断</li>
<li>操作workers变量（存在Worker类的集合）</li>
<li>统计Worker内的completedTasks变量</li>
<li>获取largestPoolSize变量<br>
...</li>
</ol>
<h3 id="worker类">Worker类</h3>
<p><b> 两个类属性</b><br>
Worker类承载线程运行业务，线程对应thread变量<br>
创建core线程或者队列已满添加非core线程时，将投递的任务作为线程的第一个执行任务，不需要从队列中获取</p>
<pre><code>Thread thread;
Runnable firstTask;
</code></pre>
<p><b> AQS此处的作用</b><br>
state变量不同值对应的含义：<br>
-1：初始化Worker类阶段<br>
0：当前线程可执行任务<br>
1：当前线程已获取任务或正在执行任务</p>
<p>开始执行任务前，需堵塞获取锁<br>
中断线程池的空闲线程前，需逐个尝试获取锁，获取成功（表示空闲）再对该线程进行中断</p>
<p>总结来说，需要根据state来判断Worker类对应线程当前的状态，并以此进行状态的判断和行为操作。</p>
<p><b>start</b><br>
以上关于Worker类及其对应线程的创建过程，修改ctl全局变量、创建Worker类、修改对应统计相关信息，最后启动线程对应执行runWorker(Worker)方法</p>
<p>有几个关键的地方：</p>
<ol>
<li>每次获取到任务（可以是首次创建传入的任务，也可以是队列中获取到的），执行业务前需要获取锁，既修改state值（此处一般不会堵塞，唯一可能造成影响的是，中断空闲线程时尝试加锁并触发中断）</li>
<li>lock完成后，需要判断线程池的状态，若线程池已为STOP以上的状态，需要确保当前线程是中断状态</li>
<li>getTask做了什么事情</li>
<li>退出轮询获取任务的循环块后，执行processWorkerExit方法做清理工作</li>
</ol>
<p>getTask<br>
一个不停的循环做逻辑判断获取任务。<br>
线程池SHUTDOWN状态并且队列为空，退出线程<br>
线程池SHUTDOWN以上状态，不再考虑队列，退出线程</p>
<p>processWorkerExit<br>
对一些统计信息做处理，每个线程退回都会尝试tryTerminate操作<br>
若中断导致的退出，会重新创建Worker<br>
若非中断导致的退出，会判断当前线程数和理论上的最小线程数之间的关系，按需添加线程（这也是空闲时，线程数变少的逻辑点）</p>
<p>allowCoreThreadTimeOut 和 keepAliveTime 的协作<br>
若设置过allowCoreThreadTimeOut为true，则core和非core线程都默认按会超时退出处理<br>
若未设置过allowCoreThreadTimeOut为true，则仅core线程按会超时退出处理，core线程会堵塞直到获取到任务或者被中断</p>
<p><b>PS：core和非core线程并无属性的区分，仅仅在于数量</b></p>
<h3 id="hashsetworker-workers">HashSet<Worker> workers</h3>
<blockquote>
<p>Set containing all worker threads in pool. Accessed only when holding mainLock.</p>
</blockquote>
<p>所有的Worker存储在workers变量里，也对应了上面提到的mainLock锁的作用点</p>
<h2 id="shutdown-和-shutdownnow-的区别">shutdown 和 shutdownNow 的区别</h2>
<pre><code>shutdown:
    checkShutdownAccess();
    advanceRunState(SHUTDOWN);
    interruptIdleWorkers();
    onShutdown(); // hook for ScheduledThreadPoolExecutor

shutdownNow:
    checkShutdownAccess();
    advanceRunState(STOP);
    interruptWorkers();
    tasks = drainQueue();
</code></pre>
<p>shutdown：</p>
<ol>
<li>修改线程池状态为SHUTDOWN，此时将不再接收新任务</li>
<li>中断<b>空闲</b>的未中断线程</li>
</ol>
<p>shutdownNow：</p>
<ol>
<li>修改线程池状态为STOP，此时将不再接收新任务，并且不再获取队列中的任务</li>
<li>中断<b>所有</b>启动的未中断线程</li>
<li>将队列中未调用的任务返回给调用者</li>
</ol>
<h1 id="运行中的线程池修改参数后的反应现象">运行中的线程池，修改参数后的反应现象</h1>
<p>线程池可修改参数</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize</li>
<li>keepAliveTime</li>
<li>threadFactory</li>
<li>rejectedExecutionHandler</li>
</ul>
<h2 id="corepoolsize">corePoolSize</h2>
<pre><code>public void setCorePoolSize(int corePoolSize) {
    if (corePoolSize &lt; 0)
        throw new IllegalArgumentException();
    int delta = corePoolSize - this.corePoolSize;
    this.corePoolSize = corePoolSize;
    if (workerCountOf(ctl.get()) &gt; corePoolSize)
        interruptIdleWorkers();
    else if (delta &gt; 0) {
        // We don't really know how many new threads are &quot;needed&quot;.
        // As a heuristic, prestart enough new workers (up to new
        // core size) to handle the current number of tasks in
        // queue, but stop if queue becomes empty while doing so.
        int k = Math.min(delta, workQueue.size());
        while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) {
            if (workQueue.isEmpty())
                break;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://voilaf.github.io/post-images/1647179789400.png" alt="" loading="lazy"></figure>
<h2 id="maximumpoolsize">maximumPoolSize</h2>
<pre><code>public void setMaximumPoolSize(int maximumPoolSize) {
    if (maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize)
        throw new IllegalArgumentException();
    this.maximumPoolSize = maximumPoolSize;
    if (workerCountOf(ctl.get()) &gt; maximumPoolSize)
        interruptIdleWorkers();
}
</code></pre>
<p>当前线程数大于新maximum，中断空闲线程</p>
<h2 id="keepalivetime">keepAliveTime</h2>
<pre><code>public void setKeepAliveTime(long time, TimeUnit unit) {
    if (time &lt; 0)
        throw new IllegalArgumentException();
    if (time == 0 &amp;&amp; allowsCoreThreadTimeOut())
        throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);
    long keepAliveTime = unit.toNanos(time);
    long delta = keepAliveTime - this.keepAliveTime;
    this.keepAliveTime = keepAliveTime;
    if (delta &lt; 0)
        interruptIdleWorkers();
}
</code></pre>
<p>新keepAliveTime小于旧keepAliveTIme，中断空闲线程</p>
<h2 id="threadfactory">threadFactory</h2>
<p>此参数修改对线程池行为并没有什么影响，但并不是一件好事，会导致已创建成功正在的旧线程与新线程不一致，如线程名词、线程daemon属性等等</p>
<h2 id="rejectedexecutionhandler">rejectedExecutionHandler</h2>
<p>可自由修改</p>
<h1 id="submit">submit</h1>
<p>发现漏了......</p>
<pre><code>public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);

public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);

class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;;

interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;;
</code></pre>
<p>两种submit的区分点：</p>
<ol>
<li>任务提交时可选择返回的结果是传入result或实际执行产生的结果</li>
<li>task将被封装到FutureTask类的callable变量，传入result时将包装称RunnableAdapter，区别仅在于RunnableAdapter执行完成真实task后，忽略其响应结果，固定返回result；未传入result则获取返回task执行的结果</li>
</ol>
<p>submit的公共点：<br>
submit方法的特点也在于和execute方法的区分点，是否可获取线程执行的结果<br>
根据方法签名可知，submit方法会返回一个Future，get方法将使用Lock.support(Thread)方法堵塞当前线程等待（可选择超时时间），上述被执行的FutureTask类在执行产生结果后，会通过LockSupport.unpark(block and wait Thread)进行锁释放</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nacos-client config杂谈]]></title>
        <id>https://voilaf.github.io/post/nacos-client-longpolling/</id>
        <link href="https://voilaf.github.io/post/nacos-client-longpolling/">
        </link>
        <updated>2022-03-07T14:24:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E9%83%A8%E5%88%86%E4%BC%AA%E4%BB%A3%E7%A0%81">关键部分伪代码</a></li>
<li><a href="#%E7%BB%BC%E4%B8%8A">综上</a></li>
</ul>
</p>
<p>最近看一个项目长轮询的代码，发现逻辑未通顺，没完整闭环，依稀记得nacos-client处有相同实现，重温并且总结。</p>
<p>注：参考nacos-client 1.x版本</p>
<h1 id="背景">背景</h1>
<ul>
<li>nacos-client config模块1.x版本基于长轮询实现</li>
<li>ClientWorker类是每个客户端与服务端交互的业务类</li>
<li>每一个配置文件对应存储映射一个CacheData类，多个CacheData存储在cacheMap（ConcurrentHashMap&lt;String, CacheData&gt; ）</li>
<li>LongPollingRunnable类顾名思义是长轮询请求服务端，获取配置信息的业务类</li>
<li>ClientWorker类包含executor和executorService线程池，对应执行LongPollingRunnable类逻辑</li>
</ul>
<h1 id="关键部分伪代码">关键部分伪代码</h1>
<pre><code>public ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,
        final Properties properties) {
    ......

    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName(&quot;com.alibaba.nacos.client.Worker.&quot; + agent.getName());
            t.setDaemon(true);
            return t;
        }
    });
    
    this.executorService = Executors
            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setName(&quot;com.alibaba.nacos.client.Worker.longPolling.&quot; + agent.getName());
                    t.setDaemon(true);
                    return t;
                }
            });
    
    this.executor.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            try {
                checkConfigInfo();
            } catch (Throwable e) {
                LOGGER.error(&quot;[&quot; + agent.getName() + &quot;] [sub-check] rotate check error&quot;, e);
            }
        }
    }, 1L, 10L, TimeUnit.MILLISECONDS);
}
</code></pre>
<p>创建了两个线程池executor和executorService，executorService作用此时未知，executor则间隔10毫秒，不断持续执行checkConfigInfo方法。</p>
<p>再来看checkConfigInfo方法</p>
<pre><code>public void checkConfigInfo() {
    // Dispatch tasks.
    int listenerSize = cacheMap.size();
    // Round up the longingTaskCount.
    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());
    if (longingTaskCount &gt; currentLongingTaskCount) {
        for (int i = (int) currentLongingTaskCount; i &lt; longingTaskCount; i++) {
            executorService.execute(new LongPollingRunnable(i));
        }
        currentLongingTaskCount = longingTaskCount;
    }
}
</code></pre>
<p>先不考虑细节，我初始单看上面两段，简单的总结：checkConfigInfo方法不停的executor被执行，LongPollingRunnable不停的被创建放到executorService被执行。好吧，其实还有下面一句代码相关，LongPollingRunnable的run方法，不停在重新投递自己到executorService，这不是会导致LongPollingRunnable任务越来越多下去吗?<br>
当然，看了<a href="https://github.com/alibaba/nacos/issues/4325">https://github.com/alibaba/nacos/issues/4325</a>这里之后很清晰的得知，人家这么设计是有意为之。</p>
<p>重点在PerTaskConfigSize方法对应的perTaskConfigSize变量，默认值是3000，可通过环境属性修改，计算得到的longingTaskCount大概率都会是1，那么新问题是checkConfigInfo方法的重试意义在哪，而perTaskConfigSize变量又有什么用？</p>
<p>保留问题，再来看LongPollingRunnable做了什么事情</p>
<pre><code>class LongPollingRunnable implements Runnable {
        
    private final int taskId;
    
    public LongPollingRunnable(int taskId) {
        this.taskId = taskId;
    }
    
    @Override
    public void run() {
        
        List&lt;CacheData&gt; cacheDatas = new ArrayList&lt;CacheData&gt;();
        List&lt;String&gt; inInitializingCacheList = new ArrayList&lt;String&gt;();
        try {
            // check failover config
            for (CacheData cacheData : cacheMap.values()) {
                if (cacheData.getTaskId() == taskId) {
                    cacheDatas.add(cacheData);
                    ......
                }
            }
            
            // check server config
            ......
            
            executorService.execute(this);
                
        } catch (Throwable e) {
                
            // If the rotation training task is abnormal, the next execution time of the task will be punished
            LOGGER.error(&quot;longPolling error : &quot;, e);
            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);
        }
    }
}
</code></pre>
<ol>
<li>从cacheMaps里面获取CacheData列表，需与taskId比对一致</li>
<li>更新处理每个CacheData对应的配置信息</li>
<li>重新投递到executorService线程池</li>
</ol>
<p>taskId值的来源及作用<br>
添加CacheData时，判断当前cacheMap的size，并计算对应的taskId</p>
<pre><code>Public CacheData addCacheDataIfAbsent(String dataId, String group, String tenant)  throws NacosException ｛
    int taskId = cacheMap.size() / (int) ParamUtil.getPerTaskConfigSize();
    cacheData.setTaskId(taskId);
｝
</code></pre>
<p>综上所述，每一个CacheData对应一个taskId，LongPollingRunnable业务线程只执行对应taskId的CacheData的更新逻辑。</p>
<p>checkConfigInfo方法的重试意义<br>
我能想到的两种可能：</p>
<ol>
<li>cacheMap的size太大了，但仍小于3000，所以仅创建一个LongPollingRunnable线程，并轮询堆cacheMap内每个CacheData处理配置更新，可能会导致效率慢，若此时改小perTaskConfigSize值，将调整创建多个LongPollingRunnable线程，每个LongPollingRunnable线程处理的CacheData数量变小，效率变高了。</li>
<li>cacheMap内的CacheData并不是初始就被创建添加，可能存在一定的延时，所以需要重试直到线程创建完成。</li>
</ol>
<p>perTaskConfigSize变量有什么用<br>
动态调整LongPollingRunnable线程数量。</p>
<h1 id="综上">综上</h1>
<p>每隔10毫秒，执行checkConfigInfo方法，判断对应条件，创建LongPollingRunnable线程并执行或不操作。<br>
LongPollingRunnable线程轮询cacheMap内的CacheData，处理配置数据更新逻辑，执行完成后向线程池自投递并反复执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xxl-job任务调度工具库]]></title>
        <id>https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/</id>
        <link href="https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/">
        </link>
        <updated>2022-03-02T13:26:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80">项目地址</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84">数据表结构</a>
<ul>
<li><a href="#%E8%A1%A8%E5%85%B3%E8%81%94%E5%9B%BE">表关联图</a></li>
<li><a href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5">表结构主要字段</a>
<ul>
<li><a href="#xxl_job_group">xxl_job_group</a></li>
<li><a href="#xxl_job_registry">xxl_job_registry</a></li>
<li><a href="#xxl_job_info">xxl_job_info</a></li>
<li><a href="#xxl_job_lock">xxl_job_lock</a></li>
<li><a href="#xxl_job_log">xxl_job_log</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%85%B3%E7%B3%BB%E5%9B%BE">管理后台关系图</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E6%B3%A8%E5%86%8C-%E6%B3%A8%E9%94%80%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">执行器注册、注销主流程图</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">任务调度过程主流程图</a></li>
<li><a href="#xxl-executor%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-executor启动流程解析</a></li>
<li><a href="#xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</a>
<ul>
<li><a href="#xxl-executor%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%A3%E6%9E%90run">xxl-executor任务调度解析：/run</a></li>
</ul>
</li>
<li><a href="#xxl-admin%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin启动流程解析</a>
<ul>
<li><a href="#xxl-admin%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin线程解析</a>
<ul>
<li><a href="#jobtriggerpoolhelper">JobTriggerPoolHelper</a></li>
<li><a href="#jobregistryhelper">JobRegistryHelper</a></li>
<li><a href="#jobfailmonitorhelper">JobFailMonitorHelper</a></li>
<li><a href="#jobcompletehelper">JobCompleteHelper</a></li>
<li><a href="#joblogreporthelper">JobLogReportHelper</a></li>
<li><a href="#jobschedulehelper">JobScheduleHelper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%90%91%E5%A4%B1%E6%B4%BB%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1">避免向失活执行器客户端调度任务</a></li>
</ul>
</p>
<h1 id="项目地址">项目地址</h1>
<p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a><br>
branch-commit-date：master-d4132524adb2179dcfc55887916b437d11f02ff1-2021.12.31</p>
<h1 id="名词解释">名词解释</h1>
<p>任务调度：xxl-admin将当前可执行且待执行的任务，发送给xxl-executor，不关注任务具体执行过程。<br>
任务执行：xxl-executor已接收到待执行任务，触发真实任务逻辑，不关注接收到任务前的过程。</p>
<h1 id="数据表结构">数据表结构</h1>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxl_job_group</td>
<td>执行器列表</td>
</tr>
<tr>
<td>xxl_job_info</td>
<td>job任务列表</td>
</tr>
<tr>
<td>xxl_job_lock</td>
<td>HA锁表</td>
</tr>
<tr>
<td>xxl_job_log</td>
<td>任务执行日志表</td>
</tr>
<tr>
<td>xxl_job_log_report</td>
<td>调度记录统计表</td>
</tr>
<tr>
<td>xxl_job_logglue</td>
<td>GLUE脚本日志表</td>
</tr>
<tr>
<td>xxl_job_registry</td>
<td>执行器客户端注册表</td>
</tr>
<tr>
<td>xxl_job_user</td>
<td>用户表</td>
</tr>
</tbody>
</table>
<h2 id="表关联图">表关联图</h2>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1646548382533.png" alt="" loading="lazy"></figure>
<h2 id="表结构主要字段">表结构主要字段</h2>
<h3 id="xxl_job_group">xxl_job_group</h3>
<p>执行器表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_name</td>
<td>varchar(64)</td>
<td>执行器AppName，业务绑定关系</td>
</tr>
<tr>
<td>address_type</td>
<td>tinyint(4)</td>
<td>执行器地址类型 0=自动注册、1=手动录入</td>
</tr>
<tr>
<td>address_list</td>
<td>text</td>
<td>执行器地址列表，多地址逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_registry">xxl_job_registry</h3>
<p>执行器客户端注册表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_key</td>
<td>varchar(255)</td>
<td>执行器AppName</td>
</tr>
<tr>
<td>registry_value</td>
<td>varchar(255)</td>
<td>客户端自注册地址（xxl-admin请求xxl-executor时访问）</td>
</tr>
<tr>
<td>update_time</td>
<td>datetime</td>
<td>更新时间（心跳更新时间，xxl-admin依次判断xxl-executor是否正常）</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_info">xxl_job_info</h3>
<p>任务表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>对应执行器，xxl_job_group表主键</td>
</tr>
<tr>
<td>schedule_type</td>
<td>varchar(50)</td>
<td>调度类型：NONE（不自动调度）、CRON（CRON表达式）、FIX_RATE（固定速率，秒）</td>
</tr>
<tr>
<td>schedule_conf</td>
<td>varchar(128)</td>
<td>调度配置，值含义取决于调度类型，如：0 0 0 * * ? *、1</td>
</tr>
<tr>
<td>misfire_strategy</td>
<td>varchar(50)</td>
<td>调度过期策略，如：DO_NOTHING、FIRE_ONCE_NOW</td>
</tr>
<tr>
<td>executor_route_strategy</td>
<td>varchar(50)</td>
<td>执行器路由策略</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler（BEAN类型时，对应XxlJob注解值</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_block_strategy</td>
<td>varchar(50)</td>
<td>阻塞处理策略，如：SERIAL_EXECUTION、DISCARD_LATER、COVER_EARLY</td>
</tr>
<tr>
<td>executor_timeout</td>
<td>int(11)</td>
<td>任务执行超时时间，单位秒</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_next_time</td>
<td>bigint(13)</td>
<td>下次调度时间</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_lock">xxl_job_lock</h3>
<p>同步表锁<br>
启动多个xxl-admin，保证高可用，查询待调度任务时，通过以下sql语句里xxl_job_lock表的写锁保证同一时刻仅一个xxl-admin处理。<br>
<code>select * from xxl_job_lock where lock_name = 'schedule_lock' for update</code></p>
<h3 id="xxl_job_log">xxl_job_log</h3>
<p>任务调度表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>xxl_job_group表主键</td>
</tr>
<tr>
<td>job_id</td>
<td>int(11)</td>
<td>xxl_job_info表主键</td>
</tr>
<tr>
<td>executor_address</td>
<td>varchar(255)</td>
<td>本地任务执行的执行器地址</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_code</td>
<td>int(11)</td>
<td>调度-结果</td>
</tr>
<tr>
<td>handle_code</td>
<td>int(11)</td>
<td>执行-状态</td>
</tr>
<tr>
<td>alarm_status</td>
<td>tinyint(4)</td>
<td>告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败</td>
</tr>
</tbody>
</table>
<h1 id="管理后台关系图">管理后台关系图</h1>
<p>pc-web：技术使用人员<br>
xxl-admin：任务调度中心、管理后台<br>
xxl-executor：客户端，即任务执行器</p>
<figure data-type="image" tabindex="2"><img src="https://voilaf.github.io/post-images/1646662062217.png" alt="" loading="lazy"></figure>
<h1 id="执行器注册-注销主流程图">执行器注册、注销主流程图</h1>
<figure data-type="image" tabindex="3"><img src="https://voilaf.github.io/post-images/1646490406389.png" alt="" loading="lazy"></figure>
<h1 id="任务调度过程主流程图">任务调度过程主流程图</h1>
<figure data-type="image" tabindex="4"><img src="https://voilaf.github.io/post-images/1646533821200.png" alt="" loading="lazy"></figure>
<h1 id="xxl-executor启动流程解析">xxl-executor启动流程解析</h1>
<p>以xxl-job-executor-sample-springboot项目为例，初始化XxlJobSpringExecutor类实例<br>
<img src="https://voilaf.github.io/post-images/1646550104379.png" alt="" loading="lazy"><br>
执行afterSingletonsInstantiated方法<br>
<img src="https://voilaf.github.io/post-images/1646552852352.png" alt="" loading="lazy"></p>
<h1 id="xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</h1>
<table>
<thead>
<tr>
<th>route-uri</th>
<th>request paramter</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/beat</td>
<td>无</td>
<td>空接口，响应固定结果</td>
</tr>
<tr>
<td>/idleBeat</td>
<td>IdleBeatParam</td>
<td>判断指定任务是否正在执行或已在队列内排队</td>
</tr>
<tr>
<td>/run</td>
<td>TriggerParam</td>
<td>触发执行任务</td>
</tr>
<tr>
<td>/kill</td>
<td>KillParam</td>
<td>移除正在执行的指定任务的线程</td>
</tr>
<tr>
<td>/log</td>
<td>LogParam</td>
<td>读取xxl_job_log表id对应的任务调度结果日志</td>
</tr>
</tbody>
</table>
<h2 id="xxl-executor任务调度解析run">xxl-executor任务调度解析：/run</h2>
<figure data-type="image" tabindex="5"><img src="https://voilaf.github.io/post-images/1646559343173.png" alt="" loading="lazy"></figure>
<h1 id="xxl-admin启动流程解析">xxl-admin启动流程解析</h1>
<figure data-type="image" tabindex="6"><img src="https://voilaf.github.io/post-images/1646566614366.png" alt="" loading="lazy"></figure>
<h2 id="xxl-admin线程解析">xxl-admin线程解析</h2>
<h3 id="jobtriggerpoolhelper">JobTriggerPoolHelper</h3>
<p><strong>toStart()</strong><br>
启动fastTriggerPool、slowTriggerPool线程池，<b>通过http请求将当前可执行且待执行的任务调度给执行器</b></p>
<p><strong>fastTriggerPool、slowTriggerPool 的区别</strong><br>
线程池参数对比</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>fastTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 200</td>
<td>LinkedBlockingQueue</td>
<td>1000</td>
<td>Abort</td>
</tr>
<tr>
<td>slowTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 100</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>Abort</td>
</tr>
</tbody>
</table>
<p><strong>什么条件下会使用slow线程池</strong></p>
<ol>
<li>触发时间间隔：单个任务必须1分钟内触发超过10次以上</li>
<li>超时大于阈值：存在10次的请求耗时超过500毫秒（不用连续）</li>
</ol>
<pre><code>// choose thread pool
ThreadPoolExecutor triggerPool_ = fastTriggerPool;
AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
if (jobTimeoutCount!=null &amp;&amp; jobTimeoutCount.get() &gt; 10) {      // job-timeout 10 times in 1 min
    triggerPool_ = slowTriggerPool;
}
</code></pre>
<p>job任务，在jobTimeoutCountMap内对应值超过10时，走慢队列。即：1分钟内存在10次以上的触发超过500毫秒</p>
<p><strong>jobTimeoutCountMap数据如何生成</strong></p>
<pre><code>// check timeout-count-map
long minTim_now = System.currentTimeMillis()/60000;
if (minTim != minTim_now) {
    minTim = minTim_now;
    jobTimeoutCountMap.clear();
}

// incr timeout-count-map
long cost = System.currentTimeMillis()-start;
if (cost &gt; 500) {       // ob-timeout threshold 500ms
    AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId, new AtomicInteger(1));
    if (timeoutCount != null) {
        timeoutCount.incrementAndGet();
    }
}
</code></pre>
<ol>
<li>jobTimeoutCountMap数据每分钟清理一次</li>
<li>当一次job触发时间超过500毫秒时，往jobTimeoutCountMap内添加数据</li>
</ol>
<p><strong>JobTriggerPoolHelper线程池逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646572277335.png" alt="" loading="lazy"></p>
<p><strong>路由策略</strong><br>
xxl-admin将根据执行器名称获取执行器客户端地址列表，结合路由策略，选择一个客户端实例进行调度</p>
<ol>
<li>ExecutorRouteFirst（第一个）<br>
获取执行器客户端地址列表第一个元素</li>
<li>ExecutorRouteLast（最后一个）<br>
获取执行器客户端地址列表最后一个元素</li>
<li>ExecutorRouteRound（轮询）<br>
记录每个job被调用的次数，每一天重置一次。<br>
key：jobId<br>
通过jobId获取对应任务总的执行次数，每次获取同时加1，将总执行次数与执行器客户端地址列表大小取模获取列表下标</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<ol start="4">
<li>ExecutorRouteRandom（随机）<br>
随机生成一个比执行器客户端地址列表容量小的值作为下标获取地址</li>
<li>ExecutorRouteConsistentHash（一致性HASH）<br>
通过TreeMap，address hash 和 jobId hash，获取对应的地址</li>
<li>ExecutorRouteLFU（最不经常使用：次数）<br>
LFU(Least Frequently Used)<br>
key：jobId<br>
value：(k：address v: 该执行器被访问次数)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = new ConcurrentHashMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();

// 核心逻辑：保存该jobId对应每个执行器的被访问次数，排序获取最小次数对应的执行器地址，同时该次数加1
// PS：每次需比对传入的addressList，删除jobLfuMap内无效的执行器地址
Collections.sort(lfuItemList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
    @Override
    public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
        return o1.getValue().compareTo(o2.getValue());
    }
});
</code></pre>
<ol start="7">
<li>ExecutorRouteLRU（最近最久未使用：时间）<br>
LRU(Least Recently Used)<br>
key：jobId<br>
value：(k：address v：address)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = new ConcurrentHashMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();
// 核心逻辑：依赖LinkedHashMap的accessOrder参数，每次get拿到的都是最久未被访问的
new LinkedHashMap&lt;String, String&gt;(16, 0.75f, true);
</code></pre>
<ol start="8">
<li>ExecutorRouteFailover（故障转移）<br>
依次轮询每个执行器address，请求/beat接口，响应成功即获取该address</li>
<li>ExecutorRouteBusyover（忙碌转移）<br>
依次轮询每个执行器address，请求/idleBeat接口，响应成功即获取该address</li>
</ol>
<p><strong>stop()</strong><br>
关闭线程池</p>
<pre><code>public void stop() {
    fastTriggerPool.shutdownNow();
    slowTriggerPool.shutdownNow();
    logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger thread pool shutdown success.&quot;;
}
</code></pre>
<h3 id="jobregistryhelper">JobRegistryHelper</h3>
<p><strong>start()</strong><br>
创建registryOrRemoveThreadPool线程池（<b>处理客户端注册、心跳包、注销逻辑</b>）、registryMonitorThread线程（<b>处理无效的客户端执行器注册信息；统计客户端地址列表</b>）</p>
<p>registryOrRemoveThreadPool线程池主参数</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>registryOrRemoveThreadPool</td>
<td>&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot; + Runnable.hashCode()</td>
<td>2</td>
<td>10</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>CallerRun</td>
</tr>
</tbody>
</table>
<p><strong>JobRegistryHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646575720794.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    registryOrRemoveThreadPool.shutdownNow();

    // stop monitir (interrupt and wait)
    registryMonitorThread.interrupt();
    try {
        registryMonitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobfailmonitorhelper">JobFailMonitorHelper</h3>
<p><strong>start()</strong><br>
创建monitorThread线程，<b>重新调度失败的任务；触发警报通知</b>，每10秒处理1次</p>
<p><strong>JobFailMonitorHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646656216162.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobcompletehelper">JobCompleteHelper</h3>
<p><strong>start()</strong><br>
创建callbackThreadPool线程池（<b>处理执行器客户端上报的任务执行结果</b>）、monitorThread线程（<b>清除调度成功10分钟未获取执行结果且对应执行器客户端丢失的任务记录</b>，每1分钟执行1次）</p>
<p><strong>JobCompleteHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646657505987.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    callbackThreadPool.shutdownNow();

    // stop monitorThread (interrupt and wait)
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="joblogreporthelper">JobLogReportHelper</h3>
<p><strong>start()</strong><br>
创建logrThread线程（<b>统计任务运行情况，生成xxl_job_log_report表数据；清除xxl_job_log表历史数据</b>），每1分钟执行1次</p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    logrThread.interrupt();
    try {
        logrThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobschedulehelper">JobScheduleHelper</h3>
<p><strong>start()</strong><br>
创建scheduleThread线程（查询待调度任务，进行调度条件分析处理，并调度任务）、ringThread线程（按秒依次调度任务）</p>
<p><strong>JobScheduleHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646660742427.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong></p>
<ol>
<li>scheduleThreadToStop设置为true，scheduleThread线程将退出执行循环，sleep1秒，并join等待scheduleThread线程执退出</li>
<li>ringData存在数据，则sleep8秒</li>
<li>ringThreadToStop设置为true，ringThread线程将退出执行循环，sleep1秒，并join等待ringThread线程执退出</li>
</ol>
<h1 id="避免向失活执行器客户端调度任务">避免向失活执行器客户端调度任务</h1>
<p><strong>背景</strong></p>
<ul>
<li>registryMonitorThread线程每隔30秒判断执行器客户端是否已超过90秒未交互心跳包（执行器自动注册），若超过则更新xxl_job_group表的address_list为最新可用的执行器客户端地址。</li>
<li>执行器客户端退出时，会请求registryRemove接口，清除本身的注册信息</li>
<li>任务调度时，会根据xxl_job_group表address_list字段值和路由策略选择一个执行器客户端实例<br>
<strong>假设场景</strong></li>
<li>执行器客户端刚完成心跳包交互同时退出，但是未请求成功registryRemove接口（也许网络问题或者客户端机器故障，等等）</li>
<li>registryMonitorThread线程需要起码90秒才能检测出该执行器实例故障<br>
<strong>关注点</strong></li>
</ul>
<ol>
<li>此时任务调度该机器会如何？<br>
任务调度会因为该实例访问异常导致请求失败。</li>
<li>如何让任务最终结果是成功的？<br>
结合xxl_job_info表executor_fail_retry_count（失败重试次数）、executor_route_strategy（路由策略）两个字段协作处理</li>
</ol>
<ul>
<li>故障转移、忙碌转移两种情况，会分别请求执行器的&quot;/beat&quot;和&quot;/idleBeat&quot;，会相应成功才会调度到该执行器，此时不需要考虑重试次数。</li>
<li>参考轮询、随机等路由策略，一次调度失败后，根据失败重试次数会重新调度（仍存在可能调度到原失活执行器）</li>
</ul>
<p><strong>结论</strong><br>
根据任务的执行周期，动态调整。如每日执行一次（可选择故障、忙碌转移并增加失败重试次数），如每1分钟执行一次（条件相对自由，若不允许失败，可选择非单机、非最后一个等固定项，并增加失败重试次数）</p>
<hr>
<p>xxl-job 社区当前并不活跃，有什么可替换且好用的项目？</p>
]]></content>
    </entry>
</feed>