<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://voilaf.github.io</id>
    <title>voilaf</title>
    <updated>2022-03-08T14:11:55.246Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://voilaf.github.io"/>
    <link rel="self" href="https://voilaf.github.io/atom.xml"/>
    <subtitle>hhh</subtitle>
    <logo>https://voilaf.github.io/images/avatar.png</logo>
    <icon>https://voilaf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, voilaf</rights>
    <entry>
        <title type="html"><![CDATA[xxl-job任务调度工具库]]></title>
        <id>https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/</id>
        <link href="https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/">
        </link>
        <updated>2022-03-02T13:26:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80">项目地址</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84">数据表结构</a>
<ul>
<li><a href="#%E8%A1%A8%E5%85%B3%E8%81%94%E5%9B%BE">表关联图</a></li>
<li><a href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5">表结构主要字段</a>
<ul>
<li><a href="#xxl_job_group">xxl_job_group</a></li>
<li><a href="#xxl_job_registry">xxl_job_registry</a></li>
<li><a href="#xxl_job_info">xxl_job_info</a></li>
<li><a href="#xxl_job_lock">xxl_job_lock</a></li>
<li><a href="#xxl_job_log">xxl_job_log</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%85%B3%E7%B3%BB%E5%9B%BE">管理后台关系图</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E6%B3%A8%E5%86%8C-%E6%B3%A8%E9%94%80%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">执行器注册、注销主流程图</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">任务调度过程主流程图</a></li>
<li><a href="#xxl-executor%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-executor启动流程解析</a></li>
<li><a href="#xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</a>
<ul>
<li><a href="#xxl-executor%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%A3%E6%9E%90run">xxl-executor任务调度解析：/run</a></li>
</ul>
</li>
<li><a href="#xxl-admin%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin启动流程解析</a>
<ul>
<li><a href="#xxl-admin%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin线程解析</a>
<ul>
<li><a href="#jobtriggerpoolhelper">JobTriggerPoolHelper</a></li>
<li><a href="#jobregistryhelper">JobRegistryHelper</a></li>
<li><a href="#jobfailmonitorhelper">JobFailMonitorHelper</a></li>
<li><a href="#jobcompletehelper">JobCompleteHelper</a></li>
<li><a href="#joblogreporthelper">JobLogReportHelper</a></li>
<li><a href="#jobschedulehelper">JobScheduleHelper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%90%91%E5%A4%B1%E6%B4%BB%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1">避免向失活执行器客户端调度任务</a></li>
</ul>
</p>
<h1 id="项目地址">项目地址</h1>
<p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a><br>
branch-commit-date：master-d4132524adb2179dcfc55887916b437d11f02ff1-2021.12.31</p>
<h1 id="名词解释">名词解释</h1>
<p>任务调度：xxl-admin将当前可执行且待执行的任务，发送给xxl-executor，不关注任务具体执行过程。<br>
任务执行：xxl-executor已接收到待执行任务，触发真实任务逻辑，不关注接收到任务前的过程。</p>
<h1 id="数据表结构">数据表结构</h1>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxl_job_group</td>
<td>执行器列表</td>
</tr>
<tr>
<td>xxl_job_info</td>
<td>job任务列表</td>
</tr>
<tr>
<td>xxl_job_lock</td>
<td>HA锁表</td>
</tr>
<tr>
<td>xxl_job_log</td>
<td>任务执行日志表</td>
</tr>
<tr>
<td>xxl_job_log_report</td>
<td>调度记录统计表</td>
</tr>
<tr>
<td>xxl_job_logglue</td>
<td>GLUE脚本日志表</td>
</tr>
<tr>
<td>xxl_job_registry</td>
<td>执行器客户端注册表</td>
</tr>
<tr>
<td>xxl_job_user</td>
<td>用户表</td>
</tr>
</tbody>
</table>
<h2 id="表关联图">表关联图</h2>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1646548382533.png" alt="" loading="lazy"></figure>
<h2 id="表结构主要字段">表结构主要字段</h2>
<h3 id="xxl_job_group">xxl_job_group</h3>
<p>执行器表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_name</td>
<td>varchar(64)</td>
<td>执行器AppName，业务绑定关系</td>
</tr>
<tr>
<td>address_type</td>
<td>tinyint(4)</td>
<td>执行器地址类型 0=自动注册、1=手动录入</td>
</tr>
<tr>
<td>address_list</td>
<td>text</td>
<td>执行器地址列表，多地址逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_registry">xxl_job_registry</h3>
<p>执行器客户端注册表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_key</td>
<td>varchar(255)</td>
<td>执行器AppName</td>
</tr>
<tr>
<td>registry_value</td>
<td>varchar(255)</td>
<td>客户端自注册地址（xxl-admin请求xxl-executor时访问）</td>
</tr>
<tr>
<td>update_time</td>
<td>datetime</td>
<td>更新时间（心跳更新时间，xxl-admin依次判断xxl-executor是否正常）</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_info">xxl_job_info</h3>
<p>任务表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>对应执行器，xxl_job_group表主键</td>
</tr>
<tr>
<td>schedule_type</td>
<td>varchar(50)</td>
<td>调度类型：NONE（不自动调度）、CRON（CRON表达式）、FIX_RATE（固定速率，秒）</td>
</tr>
<tr>
<td>schedule_conf</td>
<td>varchar(128)</td>
<td>调度配置，值含义取决于调度类型，如：0 0 0 * * ? *、1</td>
</tr>
<tr>
<td>misfire_strategy</td>
<td>varchar(50)</td>
<td>调度过期策略，如：DO_NOTHING、FIRE_ONCE_NOW</td>
</tr>
<tr>
<td>executor_route_strategy</td>
<td>varchar(50)</td>
<td>执行器路由策略</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler（BEAN类型时，对应XxlJob注解值</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_block_strategy</td>
<td>varchar(50)</td>
<td>阻塞处理策略，如：SERIAL_EXECUTION、DISCARD_LATER、COVER_EARLY</td>
</tr>
<tr>
<td>executor_timeout</td>
<td>int(11)</td>
<td>任务执行超时时间，单位秒</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_next_time</td>
<td>bigint(13)</td>
<td>下次调度时间</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_lock">xxl_job_lock</h3>
<p>同步表锁<br>
启动多个xxl-admin，保证高可用，查询待调度任务时，通过以下sql语句里xxl_job_lock表的写锁保证同一时刻仅一个xxl-admin处理。<br>
<code>select * from xxl_job_lock where lock_name = 'schedule_lock' for update</code></p>
<h3 id="xxl_job_log">xxl_job_log</h3>
<p>任务调度表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>xxl_job_group表主键</td>
</tr>
<tr>
<td>job_id</td>
<td>int(11)</td>
<td>xxl_job_info表主键</td>
</tr>
<tr>
<td>executor_address</td>
<td>varchar(255)</td>
<td>本地任务执行的执行器地址</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_code</td>
<td>int(11)</td>
<td>调度-结果</td>
</tr>
<tr>
<td>handle_code</td>
<td>int(11)</td>
<td>执行-状态</td>
</tr>
<tr>
<td>alarm_status</td>
<td>tinyint(4)</td>
<td>告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败</td>
</tr>
</tbody>
</table>
<h1 id="管理后台关系图">管理后台关系图</h1>
<p>pc-web：技术使用人员<br>
xxl-admin：任务调度中心、管理后台<br>
xxl-executor：客户端，即任务执行器</p>
<figure data-type="image" tabindex="2"><img src="https://voilaf.github.io/post-images/1646662062217.png" alt="" loading="lazy"></figure>
<h1 id="执行器注册-注销主流程图">执行器注册、注销主流程图</h1>
<figure data-type="image" tabindex="3"><img src="https://voilaf.github.io/post-images/1646490406389.png" alt="" loading="lazy"></figure>
<h1 id="任务调度过程主流程图">任务调度过程主流程图</h1>
<figure data-type="image" tabindex="4"><img src="https://voilaf.github.io/post-images/1646533821200.png" alt="" loading="lazy"></figure>
<h1 id="xxl-executor启动流程解析">xxl-executor启动流程解析</h1>
<p>以xxl-job-executor-sample-springboot项目为例，初始化XxlJobSpringExecutor类实例<br>
<img src="https://voilaf.github.io/post-images/1646550104379.png" alt="" loading="lazy"><br>
执行afterSingletonsInstantiated方法<br>
<img src="https://voilaf.github.io/post-images/1646552852352.png" alt="" loading="lazy"></p>
<h1 id="xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</h1>
<table>
<thead>
<tr>
<th>route-uri</th>
<th>request paramter</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/beat</td>
<td>无</td>
<td>空接口，响应固定结果</td>
</tr>
<tr>
<td>/idleBeat</td>
<td>IdleBeatParam</td>
<td>判断指定任务是否正在执行或已在队列内排队</td>
</tr>
<tr>
<td>/run</td>
<td>TriggerParam</td>
<td>触发执行任务</td>
</tr>
<tr>
<td>/kill</td>
<td>KillParam</td>
<td>移除正在执行的指定任务的线程</td>
</tr>
<tr>
<td>/log</td>
<td>LogParam</td>
<td>读取xxl_job_log表id对应的任务调度结果日志</td>
</tr>
</tbody>
</table>
<h2 id="xxl-executor任务调度解析run">xxl-executor任务调度解析：/run</h2>
<figure data-type="image" tabindex="5"><img src="https://voilaf.github.io/post-images/1646559343173.png" alt="" loading="lazy"></figure>
<h1 id="xxl-admin启动流程解析">xxl-admin启动流程解析</h1>
<figure data-type="image" tabindex="6"><img src="https://voilaf.github.io/post-images/1646566614366.png" alt="" loading="lazy"></figure>
<h2 id="xxl-admin线程解析">xxl-admin线程解析</h2>
<h3 id="jobtriggerpoolhelper">JobTriggerPoolHelper</h3>
<p><strong>toStart()</strong><br>
启动fastTriggerPool、slowTriggerPool线程池，<b>通过http请求将当前可执行且待执行的任务调度给执行器</b></p>
<p><strong>fastTriggerPool、slowTriggerPool 的区别</strong><br>
线程池参数对比</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>fastTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 200</td>
<td>LinkedBlockingQueue</td>
<td>1000</td>
<td>Abort</td>
</tr>
<tr>
<td>slowTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 100</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>Abort</td>
</tr>
</tbody>
</table>
<p><strong>什么条件下会使用slow线程池</strong></p>
<ol>
<li>触发时间间隔：单个任务必须1分钟内触发超过10次以上</li>
<li>超时大于阈值：存在10次的请求耗时超过500毫秒（不用连续）</li>
</ol>
<pre><code>// choose thread pool
ThreadPoolExecutor triggerPool_ = fastTriggerPool;
AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
if (jobTimeoutCount!=null &amp;&amp; jobTimeoutCount.get() &gt; 10) {      // job-timeout 10 times in 1 min
    triggerPool_ = slowTriggerPool;
}
</code></pre>
<p>job任务，在jobTimeoutCountMap内对应值超过10时，走慢队列。即：1分钟内存在10次以上的触发超过500毫秒</p>
<p><strong>jobTimeoutCountMap数据如何生成</strong></p>
<pre><code>// check timeout-count-map
long minTim_now = System.currentTimeMillis()/60000;
if (minTim != minTim_now) {
    minTim = minTim_now;
    jobTimeoutCountMap.clear();
}

// incr timeout-count-map
long cost = System.currentTimeMillis()-start;
if (cost &gt; 500) {       // ob-timeout threshold 500ms
    AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId, new AtomicInteger(1));
    if (timeoutCount != null) {
        timeoutCount.incrementAndGet();
    }
}
</code></pre>
<ol>
<li>jobTimeoutCountMap数据每分钟清理一次</li>
<li>当一次job触发时间超过500毫秒时，往jobTimeoutCountMap内添加数据</li>
</ol>
<p><strong>JobTriggerPoolHelper线程池逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646572277335.png" alt="" loading="lazy"></p>
<p><strong>路由策略</strong><br>
xxl-admin将根据执行器名称获取执行器客户端地址列表，结合路由策略，选择一个客户端实例进行调度</p>
<ol>
<li>ExecutorRouteFirst（第一个）<br>
获取执行器客户端地址列表第一个元素</li>
<li>ExecutorRouteLast（最后一个）<br>
获取执行器客户端地址列表最后一个元素</li>
<li>ExecutorRouteRound（轮询）<br>
记录每个job被调用的次数，每一天重置一次。<br>
key：jobId<br>
通过jobId获取对应任务总的执行次数，每次获取同时加1，将总执行次数与执行器客户端地址列表大小取模获取列表下标</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<ol start="4">
<li>ExecutorRouteRandom（随机）<br>
随机生成一个比执行器客户端地址列表容量小的值作为下标获取地址</li>
<li>ExecutorRouteConsistentHash（一致性HASH）<br>
通过TreeMap，address hash 和 jobId hash，获取对应的地址</li>
<li>ExecutorRouteLFU（最不经常使用：次数）<br>
LFU(Least Frequently Used)<br>
key：jobId<br>
value：(k：address v: 该执行器被访问次数)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = new ConcurrentHashMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();

// 核心逻辑：保存该jobId对应每个执行器的被访问次数，排序获取最小次数对应的执行器地址，同时该次数加1
// PS：每次需比对传入的addressList，删除jobLfuMap内无效的执行器地址
Collections.sort(lfuItemList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
    @Override
    public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
        return o1.getValue().compareTo(o2.getValue());
    }
});
</code></pre>
<ol start="7">
<li>ExecutorRouteLRU（最近最久未使用：时间）<br>
LRU(Least Recently Used)<br>
key：jobId<br>
value：(k：address v：address)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = new ConcurrentHashMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();
// 核心逻辑：依赖LinkedHashMap的accessOrder参数，每次get拿到的都是最久未被访问的
new LinkedHashMap&lt;String, String&gt;(16, 0.75f, true);
</code></pre>
<ol start="8">
<li>ExecutorRouteFailover（故障转移）<br>
依次轮询每个执行器address，请求/beat接口，响应成功即获取该address</li>
<li>ExecutorRouteBusyover（忙碌转移）<br>
依次轮询每个执行器address，请求/idleBeat接口，响应成功即获取该address</li>
</ol>
<p><strong>stop()</strong><br>
关闭线程池</p>
<pre><code>public void stop() {
    fastTriggerPool.shutdownNow();
    slowTriggerPool.shutdownNow();
    logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger thread pool shutdown success.&quot;;
}
</code></pre>
<h3 id="jobregistryhelper">JobRegistryHelper</h3>
<p><strong>start()</strong><br>
创建registryOrRemoveThreadPool线程池（<b>处理客户端注册、心跳包、注销逻辑</b>）、registryMonitorThread线程（<b>处理无效的客户端执行器注册信息；统计客户端地址列表</b>）</p>
<p>registryOrRemoveThreadPool线程池主参数</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>registryOrRemoveThreadPool</td>
<td>&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot; + Runnable.hashCode()</td>
<td>2</td>
<td>10</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>CallerRun</td>
</tr>
</tbody>
</table>
<p><strong>JobRegistryHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646575720794.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    registryOrRemoveThreadPool.shutdownNow();

    // stop monitir (interrupt and wait)
    registryMonitorThread.interrupt();
    try {
        registryMonitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobfailmonitorhelper">JobFailMonitorHelper</h3>
<p><strong>start()</strong><br>
创建monitorThread线程，<b>重新调度失败的任务；触发警报通知</b>，每10秒处理1次</p>
<p><strong>JobFailMonitorHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646656216162.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobcompletehelper">JobCompleteHelper</h3>
<p><strong>start()</strong><br>
创建callbackThreadPool线程池（<b>处理执行器客户端上报的任务执行结果</b>）、monitorThread线程（<b>清除调度成功10分钟未获取执行结果且对应执行器客户端丢失的任务记录</b>，每1分钟执行1次）</p>
<p><strong>JobCompleteHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646657505987.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    callbackThreadPool.shutdownNow();

    // stop monitorThread (interrupt and wait)
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="joblogreporthelper">JobLogReportHelper</h3>
<p><strong>start()</strong><br>
创建logrThread线程（<b>统计任务运行情况，生成xxl_job_log_report表数据；清除xxl_job_log表历史数据</b>），每1分钟执行1次</p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    logrThread.interrupt();
    try {
        logrThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobschedulehelper">JobScheduleHelper</h3>
<p><strong>start()</strong><br>
创建scheduleThread线程（查询待调度任务，进行调度条件分析处理，并调度任务）、ringThread线程（按秒依次调度任务）</p>
<p><strong>JobScheduleHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646660742427.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong></p>
<ol>
<li>scheduleThreadToStop设置为true，scheduleThread线程将退出执行循环，sleep1秒，并join等待scheduleThread线程执退出</li>
<li>ringData存在数据，则sleep8秒</li>
<li>ringThreadToStop设置为true，ringThread线程将退出执行循环，sleep1秒，并join等待ringThread线程执退出</li>
</ol>
<h1 id="避免向失活执行器客户端调度任务">避免向失活执行器客户端调度任务</h1>
<p><strong>背景</strong></p>
<ul>
<li>registryMonitorThread线程每隔30秒判断执行器客户端是否已超过90秒未交互心跳包（执行器自动注册），若超过则更新xxl_job_group表的address_list为最新可用的执行器客户端地址。</li>
<li>执行器客户端退出时，会请求registryRemove接口，清除本身的注册信息</li>
<li>任务调度时，会根据xxl_job_group表address_list字段值和路由策略选择一个执行器客户端实例<br>
<strong>假设场景</strong></li>
<li>执行器客户端刚完成心跳包交互同时退出，但是未请求成功registryRemove接口（也许网络问题或者客户端机器故障，等等）</li>
<li>registryMonitorThread线程需要起码90秒才能检测出该执行器实例故障<br>
<strong>关注点</strong></li>
</ul>
<ol>
<li>此时任务调度该机器会如何？<br>
任务调度会因为该实例访问异常导致请求失败。</li>
<li>如何让任务最终结果是成功的？<br>
结合xxl_job_info表executor_fail_retry_count（失败重试次数）、executor_route_strategy（路由策略）两个字段协作处理</li>
</ol>
<ul>
<li>故障转移、忙碌转移两种情况，会分别请求执行器的&quot;/beat&quot;和&quot;/idleBeat&quot;，会相应成功才会调度到该执行器，此时不需要考虑重试次数。</li>
<li>参考轮询、随机等路由策略，一次调度失败后，根据失败重试次数会重新调度（仍存在可能调度到原失活执行器）</li>
</ul>
<p><strong>结论</strong><br>
根据任务的执行周期，动态调整。如每日执行一次（可选择故障、忙碌转移并增加失败重试次数），如每1分钟执行一次（条件相对自由，若不允许失败，可选择非单机、非最后一个等固定项，并增加失败重试次数）</p>
<hr>
<p>xxl-job 社区当前并不活跃，有什么可替换且好用的项目？</p>
]]></content>
    </entry>
</feed>