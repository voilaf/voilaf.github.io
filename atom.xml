<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://voilaf.github.io</id>
    <title>voilaf</title>
    <updated>2022-03-13T14:47:59.889Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://voilaf.github.io"/>
    <link rel="self" href="https://voilaf.github.io/atom.xml"/>
    <subtitle>hhh</subtitle>
    <logo>https://voilaf.github.io/images/avatar.png</logo>
    <icon>https://voilaf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, voilaf</rights>
    <entry>
        <title type="html"><![CDATA[thread-pool-executor]]></title>
        <id>https://voilaf.github.io/post/thread-pool-executor/</id>
        <link href="https://voilaf.github.io/post/thread-pool-executor/">
        </link>
        <updated>2022-03-12T07:03:14.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%9B%AE%E7%9A%84">目的</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%84%8F%E4%B9%89">线程池的意义</a></li>
<li><a href="#threadpoolexecutor-%E4%BB%8B%E7%BB%8D">ThreadPoolExecutor 介绍</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0">初始化过程相关参数</a></li>
<li><a href="#core-and-maximum-pool-sizes">Core and maximum pool sizes</a></li>
<li><a href="#on-demand-construction">On-demand construction</a></li>
<li><a href="#creating-new-threads">Creating new threads</a></li>
<li><a href="#keep-alive-times">Keep-alive times</a></li>
<li><a href="#queuing">Queuing</a></li>
<li><a href="#rejected-tasks">Rejected tasks</a></li>
<li><a href="#hook-methods">Hook methods</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E7%BB%93%E6%9E%84">类结构</a>
<ul>
<li><a href="#interface-executor">interface Executor</a></li>
<li><a href="#interface-executorservice">interface ExecutorService</a></li>
<li><a href="#abstract-class-abstractexecutorservice">abstract class AbstractExecutorService</a></li>
<li><a href="#class-threadpoolexecutor">class ThreadPoolExecutor</a>
<ul>
<li><a href="#inner-class-worker">inner class Worker</a></li>
</ul>
</li>
<li><a href="#class-executors">class Executors</a></li>
</ul>
</li>
<li><a href="#%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7">状态属性</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95">状态方法</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C">线程池运行</a>
<ul>
<li><a href="#execute%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4">execute方法执行步骤</a></li>
<li><a href="#addworker%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4">addWorker方法执行步骤</a>
<ul>
<li><a href="#reentrantlock-mainlock">ReentrantLock mainLock</a></li>
<li><a href="#worker%E7%B1%BB">Worker类</a></li>
<li><a href="#hashsetworker-workers">HashSet<Worker> workers</a></li>
</ul>
</li>
<li><a href="#shutdown-%E5%92%8C-shutdownnow-%E7%9A%84%E5%8C%BA%E5%88%AB">shutdown 和 shutdownNow 的区别</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%E5%90%8E%E7%9A%84%E5%8F%8D%E5%BA%94%E7%8E%B0%E8%B1%A1">运行中的线程池，修改参数后的反应现象</a>
<ul>
<li><a href="#corepoolsize">corePoolSize</a></li>
<li><a href="#maximumpoolsize">maximumPoolSize</a></li>
<li><a href="#keepalivetime">keepAliveTime</a></li>
<li><a href="#threadfactory">threadFactory</a></li>
<li><a href="#rejectedexecutionhandler">rejectedExecutionHandler</a></li>
</ul>
</li>
<li><a href="#submit">submit</a></li>
</ul>
</p>
<h1 id="目的">目的</h1>
<p>探索运行中的线程池，修改参数后的反应现象</p>
<h1 id="线程池的意义">线程池的意义</h1>
<p>每个线程池维护一些基本的统计信息，如完成的任务数，另外，线程池定位解决两个问题：</p>
<ol>
<li>将每个任务与线程如何执行、调度解耦，不需要去显示创建线程</li>
<li>执行大量异步任务时，由于减少了每个任务的调用开销（线程不用重复创建），可以很有效的提高性能</li>
<li>提供了限制和管理资源的方法，目标对象包括线程、消费的任务等</li>
</ol>
<h1 id="threadpoolexecutor-介绍">ThreadPoolExecutor 介绍</h1>
<p>PS：类注释写的非常好，说明了类的作用和各个参数之间的关系</p>
<h2 id="初始化过程相关参数">初始化过程相关参数</h2>
<table>
<thead>
<tr>
<th>parameter</th>
<th>default value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int corePoolSize</td>
<td></td>
<td>Core pool size is the minimum number of workers to keep alive (and not allow to time out etc) unless allowCoreThreadTimeOut is set, in which case the minimum is zero.</td>
</tr>
<tr>
<td>int maximumPoolSize</td>
<td></td>
<td>Maximum pool size. Note that the actual maximum is internally bounded by CAPACITY.</td>
</tr>
<tr>
<td>long keepAliveTime</td>
<td></td>
<td>Timeout in nanoseconds for idle threads waiting for work. Threads use this timeout when there are more than corePoolSize present or if allowCoreThreadTimeOut. Otherwise they wait forever for new work.</td>
</tr>
<tr>
<td>BlockingQueue<Runnable> workQueue</td>
<td></td>
<td>The queue used for holding tasks and handing off to worker threads.</td>
</tr>
<tr>
<td>ThreadFactory threadFactory</td>
<td>new DefaultThreadFactory()</td>
<td>Factory for new threads. All threads are created using this factory (via method addWorker).</td>
</tr>
<tr>
<td>RejectedExecutionHandler handler</td>
<td>new AbortPolicy()</td>
<td>Handler called when saturated or shutdown in execute.</td>
</tr>
</tbody>
</table>
<h2 id="core-and-maximum-pool-sizes">Core and maximum pool sizes</h2>
<p>线程池将根据corePoolSize和maximumPoolSize两个绑定的值，动态自动调整池子内的线程数量。<br>
投递一个新任务时，如果当前仅存在比corePoolSize小的线程数正在运行，一个新线程Worker将会被创建来处理该任务，即便其他的Worker处于空闲状态；如果存在比corePoolSize大，比maximum小的线程池正在运行，若此时queue已满，将创建新的线程Worker。<br>
将corePoolSize和maximum的值调整一样，我们将得到一个固定大小的线程池。若设置maximum为Integer.MAX_VALUE，线程池将能够处理任意数量的任务。通常情况下，这两个参数在构造阶段被设置，但是也可以使用setCorePoolSize和setMaximumPoolSize方法动态修改值。<br>
<img src="https://voilaf.github.io/post-images/1647070731000.png" alt="" loading="lazy"></p>
<h2 id="on-demand-construction">On-demand construction</h2>
<p>默认情况下，线程池只有任务被投递时，才会开始创建core线程，但是实际上可以动态调用prestartCoreThread或者prestartAllCoreThreads方法选择创建一个或者所有的core线程。若创建线程池时传入的队列非空已有任务，该操作会很有效。</p>
<h2 id="creating-new-threads">Creating new threads</h2>
<p>线程池内通过ThreadFactory创建线程，若没有显示指定，默认使用Executors.defaultThreadFactory，使用相同的ThreadGroup、优先级，非daemon模式。我们可以使用自实现的ThreadFactory，指定thread's name，thread group，priority，daemon status等等。</p>
<h2 id="keep-alive-times">Keep-alive times</h2>
<p>如果线程池当前存在超过corePoolSize的线程，并且超出的线程连续空闲超过keepAliveTime时间，这部分线程将变成terminated状态。当线程池不再活跃的被使用时，这将减少资源的消耗。如果后续线程池重新活跃，将会创建新的线程。setKeepALiveTime方法动态调整该参数。使用Long.MAX_VALUE可以防止空闲线程退出。默认情况下，keep-alive策略只针对超出corePoolSize的非core线程有效，但是如果调用了allowCoreThreadTimeOut(true)，且keepAliveTime值大于0，将使core线程也生效。</p>
<h2 id="queuing">Queuing</h2>
<p>每个队列都可能被用来转移和持有投递的任务。<br>
有三种相关的队列使用方式：</p>
<ol>
<li>如果比corePoolSize小的线程正在运行，线程池将新增一个新的线程执行任务而不是将任务投递到队列</li>
<li>如果corePoolSize或者更多的线程正在运行，线程池将把任务投递到队列而不是新增线程</li>
<li>如果一个任务不能投递到队列，若此时线程数小于maximum，新增线程；否则任务将被拒绝<br>
有三种队列常用的策略：</li>
<li>直接交付。如SynchrnousQueue，该队列并不会持有任务，而不是直接转交给线程</li>
<li>无界队列。如LinkedBlockingQueue（初始化时未指定容量），当corePoolSize对应的线程忙碌状态时，所有新投递的任务都会被投递到队列中排队，直到有core线程空闲，此时maximumPoolSize值没有意义，不会额外创建线程</li>
<li>有界队列。如ArrayBlockingQueue，设置有限的maximumPoolSize值，可以有效防止资源耗尽，但是这会很难控制，队列容量和maximumPoolSize得做出均衡：使用大的队列容量和小的maximumPoolSize可以减少CPU使用、系统资源和上下文切换负荷，但是吞吐量会减少，既任务执行的慢了。如果任务频繁的堵塞（比如IO密集型任务），系统可能能够有比预想更多的时间去调度线程。使用小的队列通常要求更大的线程池，会导致CPU更繁忙，但是可能会碰到不可接受的调度开销，也会使吞吐量减少。</li>
</ol>
<h2 id="rejected-tasks">Rejected tasks</h2>
<p>当线程池已被shutdown或者有边界（已到达最大线程池和队列已饱和），投递任务将被拒绝。<br>
默认已预定义了四种拒绝策略：</p>
<ol>
<li>默认选择策略：AbortPolicy。拒绝任务时会抛出一个Runtime异常（RejectedExecutionException）</li>
<li>CallerRunsPolicy。投递任务的线程本身会同步执行该任务，任务执行从异步变成同步，会影响正常的业务响应</li>
<li>DiscardPolicy。投递的任务将会被丢弃，忽略不再执行</li>
<li>DiscardOldestPolicy。如果线程池未被shutdown，在队列头部的任务（最先投递）将被丢弃，并重新投递当前任务</li>
</ol>
<h2 id="hook-methods">Hook methods</h2>
<p>可以继承ThreadPoolExecutor类重写beforeExecute(Thread, Runnable)和afterExecute(Runnable, Throwable)方法，在每一个任务执行前后，增加hook</p>
<h1 id="类结构">类结构</h1>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1647068674907.png" alt="" loading="lazy"></figure>
<h2 id="interface-executor">interface Executor</h2>
<p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. However, the Executor interface does not strictly require that execution be asynchronous.</p>
<h2 id="interface-executorservice">interface ExecutorService</h2>
<p>ExecutorService implements Executor，it is a more extensive interface. An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.</p>
<h2 id="abstract-class-abstractexecutorservice">abstract class AbstractExecutorService</h2>
<p>Provides default implementations of ExecutorService execution methods. This class implements the submit, invokeAny and invokeAll methods using a RunnableFuture returned by newTaskFor, which defaults to the FutureTask class provided in this package.</p>
<h2 id="class-threadpoolexecutor">class ThreadPoolExecutor</h2>
<p>An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods.</p>
<h3 id="inner-class-worker">inner class Worker</h3>
<p>Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping.<br>
Worker类继承AbstractQueuedSynchronizer，以便于在每个任务执行时，可以简化获取和释放锁的操作，这可以防止中断时去唤醒等待任务的线程而不是一个正在执行任务的线程。另外，不使用ReentrantLock而是单独实现一个简单的排他锁是因为当线程控制方法被调用时（比如setCorePoolSize），worker不会重复的获取锁。</p>
<h2 id="class-executors">class Executors</h2>
<p>该类并不与上述几个类有直接关系，但是往往会伴随使用。<br>
Factory and utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes defined in this package. This class supports the following kinds of methods:<br>
Methods that create and return an ExecutorService set up with commonly useful configuration settings.</p>
<ul>
<li>Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings.</li>
<li>Methods that create and return a &quot;wrapped&quot; ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.</li>
<li>Methods that create and return a ThreadFactory that sets newly created threads to a known state.</li>
<li>Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable.</li>
</ul>
<h1 id="状态属性">状态属性</h1>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
</code></pre>
<blockquote>
<p>The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc In order to pack them into one int.</p>
</blockquote>
<blockquote>
<p>The workerCount is the number of workers that have been permitted to start and not permitted to stop.</p>
</blockquote>
<blockquote>
<p>The runState provides the main lifecycle control, taking on values: RUNNING: Accept new tasks and process queued tasks<br>
SHUTDOWN: Don't accept new tasks, but process queued tasks<br>
STOP: Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks<br>
TIDYING: All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method TERMINATED: terminated() has completed The numerical order among these values matters, to allow ordered comparisons.</p>
</blockquote>
<p>CAPACITY二进制表示：      0001 1111 1111 1111 1111 1111 1111 1111<br>
RUNNING二进制表示：     1110 0000 0000 0000 0000 0000 0000 0000 &lt; 0<br>
SHUTDOWN二进制表示： 0000 0000 0000 0000 0000 0000 0000 0000 = 0<br>
STOP二进制表示：             0010 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
TIDYING二进制表示：        0100 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
TERMINATED二进制表示：0110 0000 0000 0000 0000 0000 0000 0000 &gt; 0<br>
数值大于对比：RUNNING &lt; SHUTODWN &lt; STOP &lt; TIDYING &lt; TERMINATED<br>
PS：数值关系是isRunning、runStateAtLeast、runStateLessThan等状态相关方法成立的前提，线程池的状态流程是一个递进的关系</p>
<h1 id="状态方法">状态方法</h1>
<pre><code>// Packing and unpacking ctl
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>~CAPACITY有效位：1110 0000 0000 0000 0000 0000 0000 0000<br>
runStateOf方法获取线程池的运行状态<br>
workerCountOf方法获取线程池当前线程数量<br>
ctlOf方法或操作将线程池运行状态和线程池线程数量合并到一个整型变量</p>
<h1 id="线程池运行">线程池运行</h1>
<pre><code>public static void main(String[] args) {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(1));
    executor.execute(() -&gt; System.out.println(Thread.currentThread().getName()));
    executor.shutdown();
}
</code></pre>
<p>这是最常见的demo，创建了一个线程池，corePoolSize为5，maximumPoolSize为10，队列类型为LinkedBlockingQueue且容量为1。<br>
execute方法投递一个Runnable并等待执行。<br>
shutdown方法终止线程池。</p>
<h2 id="execute方法执行步骤">execute方法执行步骤</h2>
<blockquote>
<p>Proceed in 3 steps:</p>
<ol>
<li>If fewer than corePoolSize threads are running, try to<br>
start a new thread with the given command as its first<br>
task.  The call to addWorker atomically checks runState and<br>
workerCount, and so prevents false alarms that would add<br>
threads when it shouldn't, by returning false.<br>
当前存在corePoolSize个线程正在运行，添加一个新线程，并将该任务作为新线程的第一个任务，存储到内部参数里，而不会去队列内获取任务。addWorker方法可能会创建线程失败并返回false。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>If a task can be successfully queued, then we still need<br>
to double-check whether we should have added a thread<br>
(because existing ones died since last checking) or that<br>
the pool shut down since entry into this method. So we<br>
recheck state and if necessary roll back the enqueuing if<br>
stopped, or start a new thread if there are none.<br>
如果成功投递一个任务到队列中，我们需要二次检查判断当前线程池中是否存在活跃线程（如：corePoolSize等于0；或二次检查前活跃线程退出；或线程池非Running状态，将不再接受新任务）。选择从队列取出任务并reject或新创建线程。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>If we cannot queue task, then we try to add a new<br>
thread.  If it fails, we know we are shut down or saturated<br>
and so reject the task.<br>
如果队列无法投递任务，则去创建新的非core线程，若创建失败表示线程池非Running或资源已经饱和并reject。</li>
</ol>
</blockquote>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://voilaf.github.io/post-images/1647163442793.png" alt="" loading="lazy"></figure>
<h2 id="addworker方法执行步骤">addWorker方法执行步骤</h2>
<p>第一个for循环判断线程池的运行状态<br>
第二个for循环判断线程数是否符合条件并且CAS更新ctl</p>
<pre><code>private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        ......
        for (;;) {
            ......
        }
    }
}
</code></pre>
<p>检查运行状态：非RUNNING状态时，仅指定SHUTDOWN状态并且非投递任务、队列非空才创建线程</p>
<pre><code>// Check if queue empty only if necessary.
if (rs &gt;= SHUTDOWN &amp;&amp;
    ! (rs == SHUTDOWN &amp;&amp;
        firstTask == null &amp;&amp;
        ! workQueue.isEmpty()))
    return false;
</code></pre>
<p>创建core线程时，判断当前线程数是否已大于corePoolSize<br>
创建非core线程时，判断当前线程数是否已大于maximumPoolSize</p>
<pre><code>int wc = workerCountOf(c);
if (wc &gt;= CAPACITY ||
    wc &gt;= (core ? corePoolSize : maximumPoolSize))
    return false;
</code></pre>
<p>CAS操作ctl变量，线程数计数加1，增加成功则全局状态设置完成，退出两个for循环，进行剩余的线程初始化工作</p>
<pre><code>if (compareAndIncrementWorkerCount(c))
    break retry;
</code></pre>
<p>判断线程池状态是否变动，变动则重新执行第一个for循环进行线程池状态判断</p>
<pre><code>c = ctl.get();  // Re-read ctl
if (runStateOf(c) != rs)
    continue retry;
</code></pre>
<h3 id="reentrantlock-mainlock">ReentrantLock mainLock</h3>
<blockquote>
<p>Lock held on access to workers set and related bookkeeping.<br>
It also simplifies some of the associated statistics bookkeeping of largestPoolSize etc.</p>
</blockquote>
<p>根据mainLock的注释来看，是为了加锁处理Worker相关的设置和一些统计等，避免不必要的中断<br>
个别使用场景有：</p>
<ol>
<li>Worker内线程进行中断</li>
<li>操作workers变量（存在Worker类的集合）</li>
<li>统计Worker内的completedTasks变量</li>
<li>获取largestPoolSize变量<br>
...</li>
</ol>
<h3 id="worker类">Worker类</h3>
<p><b> 两个类属性</b><br>
Worker类承载线程运行业务，线程对应thread变量<br>
创建core线程或者队列已满添加非core线程时，将投递的任务作为线程的第一个执行任务，不需要从队列中获取</p>
<pre><code>Thread thread;
Runnable firstTask;
</code></pre>
<p><b> AQS此处的作用</b><br>
state变量不同值对应的含义：<br>
-1：初始化Worker类阶段<br>
0：当前线程可执行任务<br>
1：当前线程已获取任务或正在执行任务</p>
<p>开始执行任务前，需堵塞获取锁<br>
中断线程池的空闲线程前，需逐个尝试获取锁，获取成功（表示空闲）再对该线程进行中断</p>
<p>总结来说，需要根据state来判断Worker类对应线程当前的状态，并以此进行状态的判断和行为操作。</p>
<p><b>start</b><br>
以上关于Worker类及其对应线程的创建过程，修改ctl全局变量、创建Worker类、修改对应统计相关信息，最后启动线程对应执行runWorker(Worker)方法</p>
<p>有几个关键的地方：</p>
<ol>
<li>每次获取到任务（可以是首次创建传入的任务，也可以是队列中获取到的），执行业务前需要获取锁，既修改state值（此处一般不会堵塞，唯一可能造成影响的是，中断空闲线程时尝试加锁并触发中断）</li>
<li>lock完成后，需要判断线程池的状态，若线程池已为STOP以上的状态，需要确保当前线程是中断状态</li>
<li>getTask做了什么事情</li>
<li>退出轮询获取任务的循环块后，执行processWorkerExit方法做清理工作</li>
</ol>
<p>getTask<br>
一个不停的循环做逻辑判断获取任务。<br>
线程池SHUTDOWN状态并且队列为空，退出线程<br>
线程池SHUTDOWN以上状态，不再考虑队列，退出线程</p>
<p>processWorkerExit<br>
对一些统计信息做处理，每个线程退回都会尝试tryTerminate操作<br>
若中断导致的退出，会重新创建Worker<br>
若非中断导致的退出，会判断当前线程数和理论上的最小线程数之间的关系，按需添加线程（这也是空闲时，线程数变少的逻辑点）</p>
<p>allowCoreThreadTimeOut 和 keepAliveTime 的协作<br>
若设置过allowCoreThreadTimeOut为true，则core和非core线程都默认按会超时退出处理<br>
若未设置过allowCoreThreadTimeOut为true，则仅core线程按会超时退出处理，core线程会堵塞直到获取到任务或者被中断</p>
<p><b>PS：core和非core线程并无属性的区分，仅仅在于数量</b></p>
<h3 id="hashsetworker-workers">HashSet<Worker> workers</h3>
<blockquote>
<p>Set containing all worker threads in pool. Accessed only when holding mainLock.</p>
</blockquote>
<p>所有的Worker存储在workers变量里，也对应了上面提到的mainLock锁的作用点</p>
<h2 id="shutdown-和-shutdownnow-的区别">shutdown 和 shutdownNow 的区别</h2>
<pre><code>shutdown:
    checkShutdownAccess();
    advanceRunState(SHUTDOWN);
    interruptIdleWorkers();
    onShutdown(); // hook for ScheduledThreadPoolExecutor

shutdownNow:
    checkShutdownAccess();
    advanceRunState(STOP);
    interruptWorkers();
    tasks = drainQueue();
</code></pre>
<p>shutdown：</p>
<ol>
<li>修改线程池状态为SHUTDOWN，此时将不再接收新任务</li>
<li>中断<b>空闲</b>的未中断线程</li>
</ol>
<p>shutdownNow：</p>
<ol>
<li>修改线程池状态为STOP，此时将不再接收新任务，并且不再获取队列中的任务</li>
<li>中断<b>所有</b>启动的未中断线程</li>
<li>将队列中未调用的任务返回给调用者</li>
</ol>
<h1 id="运行中的线程池修改参数后的反应现象">运行中的线程池，修改参数后的反应现象</h1>
<p>线程池可修改参数</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize</li>
<li>keepAliveTime</li>
<li>threadFactory</li>
<li>rejectedExecutionHandler</li>
</ul>
<h2 id="corepoolsize">corePoolSize</h2>
<pre><code>public void setCorePoolSize(int corePoolSize) {
    if (corePoolSize &lt; 0)
        throw new IllegalArgumentException();
    int delta = corePoolSize - this.corePoolSize;
    this.corePoolSize = corePoolSize;
    if (workerCountOf(ctl.get()) &gt; corePoolSize)
        interruptIdleWorkers();
    else if (delta &gt; 0) {
        // We don't really know how many new threads are &quot;needed&quot;.
        // As a heuristic, prestart enough new workers (up to new
        // core size) to handle the current number of tasks in
        // queue, but stop if queue becomes empty while doing so.
        int k = Math.min(delta, workQueue.size());
        while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) {
            if (workQueue.isEmpty())
                break;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://voilaf.github.io/post-images/1647179789400.png" alt="" loading="lazy"></figure>
<h2 id="maximumpoolsize">maximumPoolSize</h2>
<pre><code>public void setMaximumPoolSize(int maximumPoolSize) {
    if (maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize)
        throw new IllegalArgumentException();
    this.maximumPoolSize = maximumPoolSize;
    if (workerCountOf(ctl.get()) &gt; maximumPoolSize)
        interruptIdleWorkers();
}
</code></pre>
<p>当前线程数大于新maximum，中断空闲线程</p>
<h2 id="keepalivetime">keepAliveTime</h2>
<pre><code>public void setKeepAliveTime(long time, TimeUnit unit) {
    if (time &lt; 0)
        throw new IllegalArgumentException();
    if (time == 0 &amp;&amp; allowsCoreThreadTimeOut())
        throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);
    long keepAliveTime = unit.toNanos(time);
    long delta = keepAliveTime - this.keepAliveTime;
    this.keepAliveTime = keepAliveTime;
    if (delta &lt; 0)
        interruptIdleWorkers();
}
</code></pre>
<p>新keepAliveTime小于旧keepAliveTIme，中断空闲线程</p>
<h2 id="threadfactory">threadFactory</h2>
<p>此参数修改对线程池行为并没有什么影响，但并不是一件好事，会导致已创建成功正在的旧线程与新线程不一致，如线程名词、线程daemon属性等等</p>
<h2 id="rejectedexecutionhandler">rejectedExecutionHandler</h2>
<p>可自由修改</p>
<h1 id="submit">submit</h1>
<p>发现漏了......</p>
<pre><code>public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);

public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);

class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;;

interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;;
</code></pre>
<p>两种submit的区分点：</p>
<ol>
<li>任务提交时可选择返回的结果是传入result或实际执行产生的结果</li>
<li>task将被封装到FutureTask类的callable变量，传入result时将包装称RunnableAdapter，区别仅在于RunnableAdapter执行完成真实task后，忽略其响应结果，固定返回result；未传入result则获取返回task执行的结果</li>
</ol>
<p>submit的公共点：<br>
submit方法的特点也在于和execute方法的区分点，是否可获取线程执行的结果<br>
根据方法签名可知，submit方法会返回一个Future，get方法将使用Lock.support(Thread)方法堵塞当前线程等待（可选择超时时间），上述被执行的FutureTask类在执行产生结果后，会通过LockSupport.unpark(block and wait Thread)进行锁释放</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nacos-client config杂谈]]></title>
        <id>https://voilaf.github.io/post/nacos-client-longpolling/</id>
        <link href="https://voilaf.github.io/post/nacos-client-longpolling/">
        </link>
        <updated>2022-03-07T14:24:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E9%83%A8%E5%88%86%E4%BC%AA%E4%BB%A3%E7%A0%81">关键部分伪代码</a></li>
<li><a href="#%E7%BB%BC%E4%B8%8A">综上</a></li>
</ul>
</p>
<p>最近看一个项目长轮询的代码，发现逻辑未通顺，没完整闭环，依稀记得nacos-client处有相同实现，重温并且总结。</p>
<p>注：参考nacos-client 1.x版本</p>
<h1 id="背景">背景</h1>
<ul>
<li>nacos-client config模块1.x版本基于长轮询实现</li>
<li>ClientWorker类是每个客户端与服务端交互的业务类</li>
<li>每一个配置文件对应存储映射一个CacheData类，多个CacheData存储在cacheMap（ConcurrentHashMap&lt;String, CacheData&gt; ）</li>
<li>LongPollingRunnable类顾名思义是长轮询请求服务端，获取配置信息的业务类</li>
<li>ClientWorker类包含executor和executorService线程池，对应执行LongPollingRunnable类逻辑</li>
</ul>
<h1 id="关键部分伪代码">关键部分伪代码</h1>
<pre><code>public ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,
        final Properties properties) {
    ......

    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName(&quot;com.alibaba.nacos.client.Worker.&quot; + agent.getName());
            t.setDaemon(true);
            return t;
        }
    });
    
    this.executorService = Executors
            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setName(&quot;com.alibaba.nacos.client.Worker.longPolling.&quot; + agent.getName());
                    t.setDaemon(true);
                    return t;
                }
            });
    
    this.executor.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            try {
                checkConfigInfo();
            } catch (Throwable e) {
                LOGGER.error(&quot;[&quot; + agent.getName() + &quot;] [sub-check] rotate check error&quot;, e);
            }
        }
    }, 1L, 10L, TimeUnit.MILLISECONDS);
}
</code></pre>
<p>创建了两个线程池executor和executorService，executorService作用此时未知，executor则间隔10毫秒，不断持续执行checkConfigInfo方法。</p>
<p>再来看checkConfigInfo方法</p>
<pre><code>public void checkConfigInfo() {
    // Dispatch tasks.
    int listenerSize = cacheMap.size();
    // Round up the longingTaskCount.
    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());
    if (longingTaskCount &gt; currentLongingTaskCount) {
        for (int i = (int) currentLongingTaskCount; i &lt; longingTaskCount; i++) {
            executorService.execute(new LongPollingRunnable(i));
        }
        currentLongingTaskCount = longingTaskCount;
    }
}
</code></pre>
<p>先不考虑细节，我初始单看上面两段，简单的总结：checkConfigInfo方法不停的executor被执行，LongPollingRunnable不停的被创建放到executorService被执行。好吧，其实还有下面一句代码相关，LongPollingRunnable的run方法，不停在重新投递自己到executorService，这不是会导致LongPollingRunnable任务越来越多下去吗?<br>
当然，看了<a href="https://github.com/alibaba/nacos/issues/4325">https://github.com/alibaba/nacos/issues/4325</a>这里之后很清晰的得知，人家这么设计是有意为之。</p>
<p>重点在PerTaskConfigSize方法对应的perTaskConfigSize变量，默认值是3000，可通过环境属性修改，计算得到的longingTaskCount大概率都会是1，那么新问题是checkConfigInfo方法的重试意义在哪，而perTaskConfigSize变量又有什么用？</p>
<p>保留问题，再来看LongPollingRunnable做了什么事情</p>
<pre><code>class LongPollingRunnable implements Runnable {
        
    private final int taskId;
    
    public LongPollingRunnable(int taskId) {
        this.taskId = taskId;
    }
    
    @Override
    public void run() {
        
        List&lt;CacheData&gt; cacheDatas = new ArrayList&lt;CacheData&gt;();
        List&lt;String&gt; inInitializingCacheList = new ArrayList&lt;String&gt;();
        try {
            // check failover config
            for (CacheData cacheData : cacheMap.values()) {
                if (cacheData.getTaskId() == taskId) {
                    cacheDatas.add(cacheData);
                    ......
                }
            }
            
            // check server config
            ......
            
            executorService.execute(this);
                
        } catch (Throwable e) {
                
            // If the rotation training task is abnormal, the next execution time of the task will be punished
            LOGGER.error(&quot;longPolling error : &quot;, e);
            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);
        }
    }
}
</code></pre>
<ol>
<li>从cacheMaps里面获取CacheData列表，需与taskId比对一致</li>
<li>更新处理每个CacheData对应的配置信息</li>
<li>重新投递到executorService线程池</li>
</ol>
<p>taskId值的来源及作用<br>
添加CacheData时，判断当前cacheMap的size，并计算对应的taskId</p>
<pre><code>Public CacheData addCacheDataIfAbsent(String dataId, String group, String tenant)  throws NacosException ｛
    int taskId = cacheMap.size() / (int) ParamUtil.getPerTaskConfigSize();
    cacheData.setTaskId(taskId);
｝
</code></pre>
<p>综上所述，每一个CacheData对应一个taskId，LongPollingRunnable业务线程只执行对应taskId的CacheData的更新逻辑。</p>
<p>checkConfigInfo方法的重试意义<br>
我能想到的两种可能：</p>
<ol>
<li>cacheMap的size太大了，但仍小于3000，所以仅创建一个LongPollingRunnable线程，并轮询堆cacheMap内每个CacheData处理配置更新，可能会导致效率慢，若此时改小perTaskConfigSize值，将调整创建多个LongPollingRunnable线程，每个LongPollingRunnable线程处理的CacheData数量变小，效率变高了。</li>
<li>cacheMap内的CacheData并不是初始就被创建添加，可能存在一定的延时，所以需要重试直到线程创建完成。</li>
</ol>
<p>perTaskConfigSize变量有什么用<br>
动态调整LongPollingRunnable线程数量。</p>
<h1 id="综上">综上</h1>
<p>每隔10毫秒，执行checkConfigInfo方法，判断对应条件，创建LongPollingRunnable线程并执行或不操作。<br>
LongPollingRunnable线程轮询cacheMap内的CacheData，处理配置数据更新逻辑，执行完成后向线程池自投递并反复执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xxl-job任务调度工具库]]></title>
        <id>https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/</id>
        <link href="https://voilaf.github.io/post/xxl-job-zheng-li-zong-jie/">
        </link>
        <updated>2022-03-02T13:26:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80">项目地址</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84">数据表结构</a>
<ul>
<li><a href="#%E8%A1%A8%E5%85%B3%E8%81%94%E5%9B%BE">表关联图</a></li>
<li><a href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5">表结构主要字段</a>
<ul>
<li><a href="#xxl_job_group">xxl_job_group</a></li>
<li><a href="#xxl_job_registry">xxl_job_registry</a></li>
<li><a href="#xxl_job_info">xxl_job_info</a></li>
<li><a href="#xxl_job_lock">xxl_job_lock</a></li>
<li><a href="#xxl_job_log">xxl_job_log</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%85%B3%E7%B3%BB%E5%9B%BE">管理后台关系图</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E6%B3%A8%E5%86%8C-%E6%B3%A8%E9%94%80%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">执行器注册、注销主流程图</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E4%B8%BB%E6%B5%81%E7%A8%8B%E5%9B%BE">任务调度过程主流程图</a></li>
<li><a href="#xxl-executor%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-executor启动流程解析</a></li>
<li><a href="#xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</a>
<ul>
<li><a href="#xxl-executor%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%A3%E6%9E%90run">xxl-executor任务调度解析：/run</a></li>
</ul>
</li>
<li><a href="#xxl-admin%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin启动流程解析</a>
<ul>
<li><a href="#xxl-admin%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90">xxl-admin线程解析</a>
<ul>
<li><a href="#jobtriggerpoolhelper">JobTriggerPoolHelper</a></li>
<li><a href="#jobregistryhelper">JobRegistryHelper</a></li>
<li><a href="#jobfailmonitorhelper">JobFailMonitorHelper</a></li>
<li><a href="#jobcompletehelper">JobCompleteHelper</a></li>
<li><a href="#joblogreporthelper">JobLogReportHelper</a></li>
<li><a href="#jobschedulehelper">JobScheduleHelper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%90%91%E5%A4%B1%E6%B4%BB%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1">避免向失活执行器客户端调度任务</a></li>
</ul>
</p>
<h1 id="项目地址">项目地址</h1>
<p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a><br>
branch-commit-date：master-d4132524adb2179dcfc55887916b437d11f02ff1-2021.12.31</p>
<h1 id="名词解释">名词解释</h1>
<p>任务调度：xxl-admin将当前可执行且待执行的任务，发送给xxl-executor，不关注任务具体执行过程。<br>
任务执行：xxl-executor已接收到待执行任务，触发真实任务逻辑，不关注接收到任务前的过程。</p>
<h1 id="数据表结构">数据表结构</h1>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxl_job_group</td>
<td>执行器列表</td>
</tr>
<tr>
<td>xxl_job_info</td>
<td>job任务列表</td>
</tr>
<tr>
<td>xxl_job_lock</td>
<td>HA锁表</td>
</tr>
<tr>
<td>xxl_job_log</td>
<td>任务执行日志表</td>
</tr>
<tr>
<td>xxl_job_log_report</td>
<td>调度记录统计表</td>
</tr>
<tr>
<td>xxl_job_logglue</td>
<td>GLUE脚本日志表</td>
</tr>
<tr>
<td>xxl_job_registry</td>
<td>执行器客户端注册表</td>
</tr>
<tr>
<td>xxl_job_user</td>
<td>用户表</td>
</tr>
</tbody>
</table>
<h2 id="表关联图">表关联图</h2>
<figure data-type="image" tabindex="1"><img src="https://voilaf.github.io/post-images/1646548382533.png" alt="" loading="lazy"></figure>
<h2 id="表结构主要字段">表结构主要字段</h2>
<h3 id="xxl_job_group">xxl_job_group</h3>
<p>执行器表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_name</td>
<td>varchar(64)</td>
<td>执行器AppName，业务绑定关系</td>
</tr>
<tr>
<td>address_type</td>
<td>tinyint(4)</td>
<td>执行器地址类型 0=自动注册、1=手动录入</td>
</tr>
<tr>
<td>address_list</td>
<td>text</td>
<td>执行器地址列表，多地址逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_registry">xxl_job_registry</h3>
<p>执行器客户端注册表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>registry_key</td>
<td>varchar(255)</td>
<td>执行器AppName</td>
</tr>
<tr>
<td>registry_value</td>
<td>varchar(255)</td>
<td>客户端自注册地址（xxl-admin请求xxl-executor时访问）</td>
</tr>
<tr>
<td>update_time</td>
<td>datetime</td>
<td>更新时间（心跳更新时间，xxl-admin依次判断xxl-executor是否正常）</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_info">xxl_job_info</h3>
<p>任务表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>对应执行器，xxl_job_group表主键</td>
</tr>
<tr>
<td>schedule_type</td>
<td>varchar(50)</td>
<td>调度类型：NONE（不自动调度）、CRON（CRON表达式）、FIX_RATE（固定速率，秒）</td>
</tr>
<tr>
<td>schedule_conf</td>
<td>varchar(128)</td>
<td>调度配置，值含义取决于调度类型，如：0 0 0 * * ? *、1</td>
</tr>
<tr>
<td>misfire_strategy</td>
<td>varchar(50)</td>
<td>调度过期策略，如：DO_NOTHING、FIRE_ONCE_NOW</td>
</tr>
<tr>
<td>executor_route_strategy</td>
<td>varchar(50)</td>
<td>执行器路由策略</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler（BEAN类型时，对应XxlJob注解值</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_block_strategy</td>
<td>varchar(50)</td>
<td>阻塞处理策略，如：SERIAL_EXECUTION、DISCARD_LATER、COVER_EARLY</td>
</tr>
<tr>
<td>executor_timeout</td>
<td>int(11)</td>
<td>任务执行超时时间，单位秒</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_next_time</td>
<td>bigint(13)</td>
<td>下次调度时间</td>
</tr>
</tbody>
</table>
<h3 id="xxl_job_lock">xxl_job_lock</h3>
<p>同步表锁<br>
启动多个xxl-admin，保证高可用，查询待调度任务时，通过以下sql语句里xxl_job_lock表的写锁保证同一时刻仅一个xxl-admin处理。<br>
<code>select * from xxl_job_lock where lock_name = 'schedule_lock' for update</code></p>
<h3 id="xxl_job_log">xxl_job_log</h3>
<p>任务调度表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>job_group</td>
<td>int(11)</td>
<td>xxl_job_group表主键</td>
</tr>
<tr>
<td>job_id</td>
<td>int(11)</td>
<td>xxl_job_info表主键</td>
</tr>
<tr>
<td>executor_address</td>
<td>varchar(255)</td>
<td>本地任务执行的执行器地址</td>
</tr>
<tr>
<td>executor_handler</td>
<td>varchar(255)</td>
<td>执行器任务handler</td>
</tr>
<tr>
<td>executor_param</td>
<td>varchar(512)</td>
<td>执行器任务参数</td>
</tr>
<tr>
<td>executor_fail_retry_count</td>
<td>int(11)</td>
<td>失败重试次数</td>
</tr>
<tr>
<td>trigger_code</td>
<td>int(11)</td>
<td>调度-结果</td>
</tr>
<tr>
<td>handle_code</td>
<td>int(11)</td>
<td>执行-状态</td>
</tr>
<tr>
<td>alarm_status</td>
<td>tinyint(4)</td>
<td>告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败</td>
</tr>
</tbody>
</table>
<h1 id="管理后台关系图">管理后台关系图</h1>
<p>pc-web：技术使用人员<br>
xxl-admin：任务调度中心、管理后台<br>
xxl-executor：客户端，即任务执行器</p>
<figure data-type="image" tabindex="2"><img src="https://voilaf.github.io/post-images/1646662062217.png" alt="" loading="lazy"></figure>
<h1 id="执行器注册-注销主流程图">执行器注册、注销主流程图</h1>
<figure data-type="image" tabindex="3"><img src="https://voilaf.github.io/post-images/1646490406389.png" alt="" loading="lazy"></figure>
<h1 id="任务调度过程主流程图">任务调度过程主流程图</h1>
<figure data-type="image" tabindex="4"><img src="https://voilaf.github.io/post-images/1646533821200.png" alt="" loading="lazy"></figure>
<h1 id="xxl-executor启动流程解析">xxl-executor启动流程解析</h1>
<p>以xxl-job-executor-sample-springboot项目为例，初始化XxlJobSpringExecutor类实例<br>
<img src="https://voilaf.github.io/post-images/1646550104379.png" alt="" loading="lazy"><br>
执行afterSingletonsInstantiated方法<br>
<img src="https://voilaf.github.io/post-images/1646552852352.png" alt="" loading="lazy"></p>
<h1 id="xxl-executor-embedserver-endpoint">xxl-executor: EmbedServer Endpoint</h1>
<table>
<thead>
<tr>
<th>route-uri</th>
<th>request paramter</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/beat</td>
<td>无</td>
<td>空接口，响应固定结果</td>
</tr>
<tr>
<td>/idleBeat</td>
<td>IdleBeatParam</td>
<td>判断指定任务是否正在执行或已在队列内排队</td>
</tr>
<tr>
<td>/run</td>
<td>TriggerParam</td>
<td>触发执行任务</td>
</tr>
<tr>
<td>/kill</td>
<td>KillParam</td>
<td>移除正在执行的指定任务的线程</td>
</tr>
<tr>
<td>/log</td>
<td>LogParam</td>
<td>读取xxl_job_log表id对应的任务调度结果日志</td>
</tr>
</tbody>
</table>
<h2 id="xxl-executor任务调度解析run">xxl-executor任务调度解析：/run</h2>
<figure data-type="image" tabindex="5"><img src="https://voilaf.github.io/post-images/1646559343173.png" alt="" loading="lazy"></figure>
<h1 id="xxl-admin启动流程解析">xxl-admin启动流程解析</h1>
<figure data-type="image" tabindex="6"><img src="https://voilaf.github.io/post-images/1646566614366.png" alt="" loading="lazy"></figure>
<h2 id="xxl-admin线程解析">xxl-admin线程解析</h2>
<h3 id="jobtriggerpoolhelper">JobTriggerPoolHelper</h3>
<p><strong>toStart()</strong><br>
启动fastTriggerPool、slowTriggerPool线程池，<b>通过http请求将当前可执行且待执行的任务调度给执行器</b></p>
<p><strong>fastTriggerPool、slowTriggerPool 的区别</strong><br>
线程池参数对比</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>fastTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 200</td>
<td>LinkedBlockingQueue</td>
<td>1000</td>
<td>Abort</td>
</tr>
<tr>
<td>slowTriggerPool</td>
<td>&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot; + Runnable.hashCode()</td>
<td>10</td>
<td>default: 100</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>Abort</td>
</tr>
</tbody>
</table>
<p><strong>什么条件下会使用slow线程池</strong></p>
<ol>
<li>触发时间间隔：单个任务必须1分钟内触发超过10次以上</li>
<li>超时大于阈值：存在10次的请求耗时超过500毫秒（不用连续）</li>
</ol>
<pre><code>// choose thread pool
ThreadPoolExecutor triggerPool_ = fastTriggerPool;
AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
if (jobTimeoutCount!=null &amp;&amp; jobTimeoutCount.get() &gt; 10) {      // job-timeout 10 times in 1 min
    triggerPool_ = slowTriggerPool;
}
</code></pre>
<p>job任务，在jobTimeoutCountMap内对应值超过10时，走慢队列。即：1分钟内存在10次以上的触发超过500毫秒</p>
<p><strong>jobTimeoutCountMap数据如何生成</strong></p>
<pre><code>// check timeout-count-map
long minTim_now = System.currentTimeMillis()/60000;
if (minTim != minTim_now) {
    minTim = minTim_now;
    jobTimeoutCountMap.clear();
}

// incr timeout-count-map
long cost = System.currentTimeMillis()-start;
if (cost &gt; 500) {       // ob-timeout threshold 500ms
    AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId, new AtomicInteger(1));
    if (timeoutCount != null) {
        timeoutCount.incrementAndGet();
    }
}
</code></pre>
<ol>
<li>jobTimeoutCountMap数据每分钟清理一次</li>
<li>当一次job触发时间超过500毫秒时，往jobTimeoutCountMap内添加数据</li>
</ol>
<p><strong>JobTriggerPoolHelper线程池逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646572277335.png" alt="" loading="lazy"></p>
<p><strong>路由策略</strong><br>
xxl-admin将根据执行器名称获取执行器客户端地址列表，结合路由策略，选择一个客户端实例进行调度</p>
<ol>
<li>ExecutorRouteFirst（第一个）<br>
获取执行器客户端地址列表第一个元素</li>
<li>ExecutorRouteLast（最后一个）<br>
获取执行器客户端地址列表最后一个元素</li>
<li>ExecutorRouteRound（轮询）<br>
记录每个job被调用的次数，每一天重置一次。<br>
key：jobId<br>
通过jobId获取对应任务总的执行次数，每次获取同时加1，将总执行次数与执行器客户端地址列表大小取模获取列表下标</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<ol start="4">
<li>ExecutorRouteRandom（随机）<br>
随机生成一个比执行器客户端地址列表容量小的值作为下标获取地址</li>
<li>ExecutorRouteConsistentHash（一致性HASH）<br>
通过TreeMap，address hash 和 jobId hash，获取对应的地址</li>
<li>ExecutorRouteLFU（最不经常使用：次数）<br>
LFU(Least Frequently Used)<br>
key：jobId<br>
value：(k：address v: 该执行器被访问次数)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = new ConcurrentHashMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();

// 核心逻辑：保存该jobId对应每个执行器的被访问次数，排序获取最小次数对应的执行器地址，同时该次数加1
// PS：每次需比对传入的addressList，删除jobLfuMap内无效的执行器地址
Collections.sort(lfuItemList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
    @Override
    public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) {
        return o1.getValue().compareTo(o2.getValue());
    }
});
</code></pre>
<ol start="7">
<li>ExecutorRouteLRU（最近最久未使用：时间）<br>
LRU(Least Recently Used)<br>
key：jobId<br>
value：(k：address v：address)</li>
</ol>
<pre><code>private static ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = new ConcurrentHashMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();
// 核心逻辑：依赖LinkedHashMap的accessOrder参数，每次get拿到的都是最久未被访问的
new LinkedHashMap&lt;String, String&gt;(16, 0.75f, true);
</code></pre>
<ol start="8">
<li>ExecutorRouteFailover（故障转移）<br>
依次轮询每个执行器address，请求/beat接口，响应成功即获取该address</li>
<li>ExecutorRouteBusyover（忙碌转移）<br>
依次轮询每个执行器address，请求/idleBeat接口，响应成功即获取该address</li>
</ol>
<p><strong>stop()</strong><br>
关闭线程池</p>
<pre><code>public void stop() {
    fastTriggerPool.shutdownNow();
    slowTriggerPool.shutdownNow();
    logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger thread pool shutdown success.&quot;;
}
</code></pre>
<h3 id="jobregistryhelper">JobRegistryHelper</h3>
<p><strong>start()</strong><br>
创建registryOrRemoveThreadPool线程池（<b>处理客户端注册、心跳包、注销逻辑</b>）、registryMonitorThread线程（<b>处理无效的客户端执行器注册信息；统计客户端地址列表</b>）</p>
<p>registryOrRemoveThreadPool线程池主参数</p>
<table>
<thead>
<tr>
<th>线程池变量名</th>
<th>线程名</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>queue</th>
<th>queue-size</th>
<th>rejectedPolicy</th>
</tr>
</thead>
<tbody>
<tr>
<td>registryOrRemoveThreadPool</td>
<td>&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot; + Runnable.hashCode()</td>
<td>2</td>
<td>10</td>
<td>LinkedBlockingQueue</td>
<td>2000</td>
<td>CallerRun</td>
</tr>
</tbody>
</table>
<p><strong>JobRegistryHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646575720794.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    registryOrRemoveThreadPool.shutdownNow();

    // stop monitir (interrupt and wait)
    registryMonitorThread.interrupt();
    try {
        registryMonitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobfailmonitorhelper">JobFailMonitorHelper</h3>
<p><strong>start()</strong><br>
创建monitorThread线程，<b>重新调度失败的任务；触发警报通知</b>，每10秒处理1次</p>
<p><strong>JobFailMonitorHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646656216162.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobcompletehelper">JobCompleteHelper</h3>
<p><strong>start()</strong><br>
创建callbackThreadPool线程池（<b>处理执行器客户端上报的任务执行结果</b>）、monitorThread线程（<b>清除调度成功10分钟未获取执行结果且对应执行器客户端丢失的任务记录</b>，每1分钟执行1次）</p>
<p><strong>JobCompleteHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646657505987.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;

    // stop registryOrRemoveThreadPool
    callbackThreadPool.shutdownNow();

    // stop monitorThread (interrupt and wait)
    monitorThread.interrupt();
    try {
        monitorThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="joblogreporthelper">JobLogReportHelper</h3>
<p><strong>start()</strong><br>
创建logrThread线程（<b>统计任务运行情况，生成xxl_job_log_report表数据；清除xxl_job_log表历史数据</b>），每1分钟执行1次</p>
<p><strong>toStop()</strong><br>
关闭相关线程</p>
<pre><code>public void toStop(){
    toStop = true;
    // interrupt and wait
    logrThread.interrupt();
    try {
        logrThread.join();
    } catch (InterruptedException e) {
        logger.error(e.getMessage(), e);
    }
}
</code></pre>
<h3 id="jobschedulehelper">JobScheduleHelper</h3>
<p><strong>start()</strong><br>
创建scheduleThread线程（查询待调度任务，进行调度条件分析处理，并调度任务）、ringThread线程（按秒依次调度任务）</p>
<p><strong>JobScheduleHelper相关线程逻辑流程图</strong><br>
<img src="https://voilaf.github.io/post-images/1646660742427.png" alt="" loading="lazy"></p>
<p><strong>toStop()</strong></p>
<ol>
<li>scheduleThreadToStop设置为true，scheduleThread线程将退出执行循环，sleep1秒，并join等待scheduleThread线程执退出</li>
<li>ringData存在数据，则sleep8秒</li>
<li>ringThreadToStop设置为true，ringThread线程将退出执行循环，sleep1秒，并join等待ringThread线程执退出</li>
</ol>
<h1 id="避免向失活执行器客户端调度任务">避免向失活执行器客户端调度任务</h1>
<p><strong>背景</strong></p>
<ul>
<li>registryMonitorThread线程每隔30秒判断执行器客户端是否已超过90秒未交互心跳包（执行器自动注册），若超过则更新xxl_job_group表的address_list为最新可用的执行器客户端地址。</li>
<li>执行器客户端退出时，会请求registryRemove接口，清除本身的注册信息</li>
<li>任务调度时，会根据xxl_job_group表address_list字段值和路由策略选择一个执行器客户端实例<br>
<strong>假设场景</strong></li>
<li>执行器客户端刚完成心跳包交互同时退出，但是未请求成功registryRemove接口（也许网络问题或者客户端机器故障，等等）</li>
<li>registryMonitorThread线程需要起码90秒才能检测出该执行器实例故障<br>
<strong>关注点</strong></li>
</ul>
<ol>
<li>此时任务调度该机器会如何？<br>
任务调度会因为该实例访问异常导致请求失败。</li>
<li>如何让任务最终结果是成功的？<br>
结合xxl_job_info表executor_fail_retry_count（失败重试次数）、executor_route_strategy（路由策略）两个字段协作处理</li>
</ol>
<ul>
<li>故障转移、忙碌转移两种情况，会分别请求执行器的&quot;/beat&quot;和&quot;/idleBeat&quot;，会相应成功才会调度到该执行器，此时不需要考虑重试次数。</li>
<li>参考轮询、随机等路由策略，一次调度失败后，根据失败重试次数会重新调度（仍存在可能调度到原失活执行器）</li>
</ul>
<p><strong>结论</strong><br>
根据任务的执行周期，动态调整。如每日执行一次（可选择故障、忙碌转移并增加失败重试次数），如每1分钟执行一次（条件相对自由，若不允许失败，可选择非单机、非最后一个等固定项，并增加失败重试次数）</p>
<hr>
<p>xxl-job 社区当前并不活跃，有什么可替换且好用的项目？</p>
]]></content>
    </entry>
</feed>